class e{constructor(e,s={}){this.bp=e,this.config=s.config||this.bp.config||{host:"",api:""},this.api=buddypond,this.api.endpoint=`${this.config.api}/api/v6`,this.queuedMessages=[],this.messagesWsClients=new Map,this.subscriptions=new Map,this.keepaliveInterval=null}async init(){let e={onmessage:e=>this.handleWorkerMessage(e),onerror:e=>console.error("Worker Error:",e)};return this.worker=await this.bp.createWorker("/apps/based/client/clientWorker.js",e),this.worker.onmessage=s=>{this.bp.log("Message from worker:",s.data),e.onmessage(s.data)},this.worker.onerror=s=>{console.error("Worker error:",s),e.onerror(s)},this}startKeepaliveTimer(){this.keepaliveInterval||(this.keepaliveInterval=setInterval((()=>{buddypond.keepAlive(),this.bp.log("Keepalive ping sent")}),3e4))}stopKeepaliveTimer(){this.keepaliveInterval&&(clearInterval(this.keepaliveInterval),this.keepaliveInterval=null)}sendWsMessage(e,s){let t=this.messagesWsClients.get(e);t&&t.wsClient?t.wsClient.send(JSON.stringify(s)):console.log("buddypond.messagesWs not connected, unable to send message to",e,s)}getConnectedUsers(e){if(alert("getConnectedUsers called for "+e),this.bp.log("getConnectedUsers called"),this.messagesWsClients.has(e)){let s=this.messagesWsClients.get(e);s&&s.wsClient?(this.bp.log("buddypond.messagesWsClients has",e,"sending getConnectedUsers message"),s.wsClient.send(JSON.stringify({action:"getConnectedUsers"}))):this.bp.log("No WebSocket client found for",e)}else this.bp.log("No WebSocket client found for",e,"unable to send getConnectedUsers message")}addSubscription(e,s){let t=e+"/"+s;if("buddy"===e){t=e+"/"+[buddypond.me,s].sort().join("/")}console.log(`subscribeMessages subscribing to ${t}`),this.messagesWsClients.has(t)||this.createWebSocketClient(t)}removeSubscription(e,s){let t=e+"/"+s;if("buddy"===e){t=e+"/"+[buddypond.me,s].sort().join("/")}if(console.log(`unsubscribeMessages unsubscribing from ${t}`),this.messagesWsClients.has(t)){console.log(`buddypond.messagesWsClients has ${t}, closing connection`);let e=this.messagesWsClients.get(t);console.log("closing chatConnection",e),console.log("Before close, readyState:",e.wsClient.readyState),e.wsClient.closeConnection()}}connect(){}sendMessage(e){this.bp.log("sendMessage",e),e.me=this.api.me}disconnect(){this.bp.log("Disconnecting all WebSocket clients"),this.messagesWsClients.forEach((e=>{e.wsClient.closeConnection()}))}logout(){this.disconnect(),this.qtokenid=null,this.api.qtokenid=null,this.api.me="Guest",this.me="Guest",this.bp.me="Guest",this.bp.qtokenid=null,localStorage.removeItem("qtokenid"),localStorage.removeItem("me"),this.bp.emit("auth::logout")}}e.prototype.createWebSocketClient=function e(s){let t=this.messagesWsClients.get(s),o=0;t?(console.log(`Reusing existing chatConnection for chatId: ${s}, reconnectAttempts: ${t.reconnectAttempts}`),o=t.reconnectAttempts):console.log(`Creating new WebSocket client for chatId: ${s}`);const n=new WebSocket(`${buddypond.messagesWsEndpoint}?me=${buddypond.me}&qtokenid=${buddypond.qtokenid}&chatId=${s}`);t={wsClient:n,reconnectAttempts:o,maxReconnectAttempts:999999,maxBackoffDelay:1e4},this.messagesWsClients.set(s,t);let i=!1;function r(){console.log("WebSocket connection opened to",s),o=0,t.reconnectAttempts=0,t.wsClient.send(JSON.stringify({action:"getHistory",chatId:s,profilePicture:this.bp.apps.buddylist.data.profileState.profilePicture,buddyname:buddypond.me,qtokenid:buddypond.qtokenid})),t.wsClient.send(JSON.stringify({action:"getConnectedUsers",chatId:s,buddyname:buddypond.me,qtokenid:buddypond.qtokenid}));const e=this.bp.apps.ui.windowManager.getWindow("pond_message_main");if(e){const t=e.content.querySelector(`.aim-room-item[data-pond="${s}"]`);if(t){const e=t.querySelector(".aim-room-list-item-name");e&&e.classList.add("aim-room-active")}}}async function a(e){try{const s=JSON.parse(e.data);switch(s.action){case"message":bp.emit("buddy::messages",{result:{messages:[s.message]}});break;case"connectedUsers":bp.emit("pond::connectedUsers",s);break;case"typing":bp.emit("buddy::isTyping",s.message);break;case"rate-limit":if(console.log("Rate limit exceeded:",s),bp.emit("buddy::messages",{result:{messages:[s.message],retryAfter:s.retryAfter,severity:s.severity}}),console.error(s.severity,s.message.text),3==s.severity&&alert("Please chill out."),4==s.severity)try{(await this.bp.importModule("/v5/apps/based/spellbook/spells/forbiddenRickRoll/forbiddenRickRoll.js",{},!1)).default.call(this)}catch(e){console.log("Error importing spell module:",e)}if(s.severity>=5)try{(await this.bp.importModule("/v5/apps/based/spellbook/spells/vortex/vortex.js",{},!1)).default.call(this)}catch(e){console.log("Error importing spell module:",e)}break;case"getHistory":bp.emit("buddy::messages",{result:{messages:s.messages}});break;case"removeInstantMessage":console.log("removeInstantMessage message received:",s),bp.emit("buddy::messages",{result:{messages:[s.message]}});break;case"editInstantMessage":console.log("editInstantMessage message received:",s),bp.emit("buddy::messages",{result:{messages:[s.message]}});break;default:console.warn("Unknown action received:",s)}}catch(e){console.error("Error parsing WebSocket message:",e)}}function l(n){if(console.log("WebSocket connection closed to",s,"Code:",n.code,"Reason:",n.reason),console.log("reconnectAttempts:",t.reconnectAttempts),console.log("isIntentionallyClosed:",i),(i||t.reconnectAttempts>=t.maxReconnectAttempts)&&(console.log(`Removing chatConnection for ${s} from messagesWsClients`),this.messagesWsClients.delete(s),console.log("Current WebSocket clients:",this.messagesWsClients)),!i&&t.reconnectAttempts<t.maxReconnectAttempts){const n=Math.min(200*Math.pow(2,t.reconnectAttempts)*(1+.1*Math.random()),t.maxBackoffDelay);console.log(`Scheduling reconnect attempt ${t.reconnectAttempts+1} for ${s} in ${n}ms`),setTimeout((()=>{o++,t.reconnectAttempts++,e.call(this,s)}),n)}else t.reconnectAttempts>=t.maxReconnectAttempts&&console.error(`Max reconnect attempts (${t.maxReconnectAttempts}) reached for ${s}. Giving up.`)}function c(e){console.error("WebSocket error for",s,e),t.wsClient.close(1e3,"Error occurred")}return n.addEventListener("open",r.bind(this)),n.addEventListener("message",a.bind(this)),n.addEventListener("close",l.bind(this)),n.addEventListener("error",c.bind(this)),n.closeConnection=function(){i=!0,console.log(`Intentionally closing WebSocket for ${s}`),t.wsClient.close(1e3,"Normal closure"),t.wsClient.removeEventListener("open",r),t.wsClient.removeEventListener("message",a),t.wsClient.removeEventListener("close",l),t.wsClient.removeEventListener("error",c)},n};export{e as default};
//# sourceMappingURL=client.js.map
