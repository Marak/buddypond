{"version":3,"file":"entity.js","sources":["../../../apps/based/entity/lib/util/ensureColorInt.js","../../../apps/based/entity/lib/layoutEntity.js","../../../apps/based/entity/lib/createEntity.js","../../../apps/based/entity/lib/getEntity.js","../../../apps/based/entity/lib/inflateEntity.js","../../../apps/based/entity/lib/removeEntity.js","../../../apps/based/entity/lib/updateEntity.js","../../../apps/based/entity/lib/removeAllEntities.js","../../../apps/based/entity/EntityClass.js","../../../apps/based/entity/Component.js","../../../apps/based/entity/entity.js"],"sourcesContent":["export default function ensureColorInt(color) {\n\n  if (!color) {\n    return color;\n  }\n\n  // Mapping of common color names to hex values\n  const colorNameToHex = {\n    red: '#FF0000',\n    green: '#00FF00',\n    blue: '#0000FF',\n    black: '#000000',\n    white: '#FFFFFF',\n    yellow: '#FFFF00',\n    purple: '#800080',\n    orange: '#FFA500',\n    pink: '#FFC0CB',\n    indigo: '#4B0082',\n    violet: '#EE82EE',\n    // Add more common colors as needed\n  };\n\n  // If color is already a number, return it as is\n  if (typeof color === 'number') {\n    return color;\n  }\n\n  // If color is a hex string (with #), convert it to an integer\n  if (typeof color === 'string' && color.startsWith('#')) {\n    return parseInt(color.replace('#', ''), 16);\n  }\n\n  // If color is a common color name, convert it using the mapping\n  if (typeof color === 'string' && colorNameToHex[color.toLowerCase()]) {\n    return parseInt(colorNameToHex[color.toLowerCase()].replace('#', ''), 16);\n  }\n\n  // If color format is unrecognized, throw an error or return a default color\n  console.error('Unrecognized color format:', color);\n  return parseInt('000000', 16); // Default to black\n}","// TODO: needs to be able to attach by container/entity id or name, not just by name\nexport default function layoutEntity(container, entityId) {\n\n  let containerEnt = this.game.findEntity(container); // Adjust this line to match how you access the boss entity\n\n  if (!containerEnt) {\n    throw new Error('Container not found: ' + container);\n  }\n  let containerPosition = containerEnt.position || { x: 0, y: 0, z: 0 };\n  // console.log('found container ent to work with', containerEnt);\n\n  let layoutType = 'none'; // 'none', 'grid', 'flex', 'stack', 'custom-function'\n  let origin = 'center'; // 'center', 'bottom-right', 'top-right', 'bottom-left', 'center-left', 'center-right', 'top-center', 'bottom-center', 'top-left'\n\n  // Legacy API, don't pollute style scope with new / unknown  properties\n  if (containerEnt.style && containerEnt.style.layout) {\n    layoutType = containerEnt.style.layout;\n  }\n  if (containerEnt.style && containerEnt.style.origin) {\n    origin = containerEnt.style.origin;\n  }\n\n  // New API\n  if (containerEnt.meta && containerEnt.meta.layout) {\n    layoutType = containerEnt.meta.layout;\n  }\n\n  //\n  // Add the current new entity id to the container items\n  //\n  if (!containerEnt.items) {\n    containerEnt.items = [];\n  }\n  containerEnt.items.push(entityId); // Remark: We are not saving the associations here?\n\n  // TODO: add better support for 1:1 flex mapping\n  if (layoutType === 'flex') {\n    const flexConfig = containerEnt.meta.flex || containerEnt.style.flex; // Assuming flex config is stored here\n    const items = containerEnt.items.map(itemId => this.game.getEntity(itemId));\n    applyFlexLayout.call(this, containerEnt, items, flexConfig);\n  } else if (layoutType === 'grid') {\n    const gridConfig = containerEnt.meta.grid || containerEnt.style.grid; // Assuming grid config is stored here\n    const items = containerEnt.items.map(itemId => this.game.getEntity(itemId));\n    applyGridLayout.call(this, containerEnt, items, gridConfig);\n  }\n\n  //\n  // Default / no layout indicates relative position from top left origin ( -1, -1 )\n  // Remark: May want to add custom origins such as center ( 0, 0 ) or bottom right ( 1, 1 ), etc\n  //\n  if (layoutType === 'none') {\n    // Retrieve the entity to be positioned\n    let entity = this.game.getEntity(entityId);\n\n    // Check if entity exists\n    if (!entity) {\n      console.error('Entity not found: ' + entityId);\n      return;\n    }\n\n    // When the origin should be centered, calculate offsets to position the entity's center at the container's center\n    let offsetX = entity.position.x; // Centered horizontally\n    let offsetY = entity.position.y; // Centered vertically\n    // If the origin is explicitly set to 'top-left', adjust offsets to position the top-left corner of the entity at the container's center\n    // TODO: fix this and move to separate file / sub-system for layout / flex styles / etc\n    if (origin === 'top-left') {\n      offsetX = -entity.size.width / 2;\n      offsetY = -entity.size.height / 2;\n    } else {\n      // For a centered origin, adjust so the entity's center aligns with the container's center\n      offsetX -= entity.size.width / 2;\n      offsetY -= entity.size.height / 2;\n    }\n\n    // Calculate the cumulative position of the container to account for nesting\n    // TODO: traverse up the container hierarchy to get the cumulative position\n    // let cumulativeContainerPosition = getCumulativePosition(containerEnt);\n    let cumulativeContainerPosition = containerEnt.position;\n    \n    // Calculate the entity's new position relative to the cumulative container position\n    let newPosition = {\n      x: cumulativeContainerPosition.x + (origin === 'top-left' ? -entity.size.width / 2 : -entity.size.width / 2),\n      y: cumulativeContainerPosition.y + (origin === 'top-left' ? -entity.size.height / 2 : -entity.size.height / 2),\n      z: containerPosition.z // Assuming z-index remains constant or is managed elsewhere\n    };\n\n\n    newPosition.x = containerPosition.x + offsetX;\n    newPosition.y = containerPosition.y + offsetY;\n\n    // Update the entity's position\n    this.game.updateEntity({ id: entityId, position: newPosition });\n\n    // Log for debugging purposes\n    // console.log(`Entity ${entityId} positioned at (${newPosition.x}, ${newPosition.y}, ${newPosition.z}) relative to container`);\n  }\n\n\n  //\n  // Layout container items using grid layout algorithm\n  //\n\n  if (layoutType === 'grid') {\n\n    let cols = containerEnt.meta.grid.columns || 1;\n    let rows = containerEnt.meta.grid.rows || 1;\n\n    if (containerEnt.style && containerEnt.style.grid) {\n      cols = containerEnt.style.grid.columns || cols;\n      rows = containerEnt.style.grid.rows || rows;\n    }\n\n    if (typeof cols !== 'number' || typeof rows !== 'number') {\n      console.log('containerEnt.layout', containerEnt.layout);\n      throw new Error('Grid layout requires cols and rows to be numbers');\n    }\n\n    //console.log(\"ahhhhhhhhhh\", cols, rows)\n    // get all the other items in the container\n    let containerItems = containerEnt.items || [];\n\n    // call game.getEntity() for each item to get its size and position\n    // Remark: use components api to only fetch the necessary components ( instead of entire ent )\n    containerItems = containerItems.map((itemId) => {\n      return this.game.getEntity(itemId);\n    });\n\n    let containerSize = containerEnt.size;\n\n    // Calculate the width and height for each grid cell\n    let cellWidth = containerSize.width / cols;\n    let cellHeight = containerSize.height / rows;\n    //alert(containerSize.width)\n    //alert(containerSize.height)\n\n    // Loop through each item in the container\n    containerItems.forEach((item, index) => {\n      // Calculate the row and column for the current item based on its index\n      let row = Math.floor(index / cols);\n      let col = index % cols;\n\n      // skip if item is not found\n      if (!item) {\n        // Remark: This should *not* happen, investigate why index is null value\n        console.log('warning: item not found in container', index, item)\n        return;\n      }\n\n      let paddingTop = 0;\n      let paddingLeft = 0;\n      // Set the starting position to the top-left corner of the container's bounding box\n      let positionX = containerPosition.x - containerSize.width / 2 + paddingLeft;\n      let positionY = containerPosition.y - containerSize.height / 2 + paddingTop;\n      let positionZ = containerPosition.z;\n\n      // Calculate the position for the current item, aligning the center of the entity with the center of the grid cell\n      let itemPosition = {\n        x: positionX + (col * cellWidth) + (cellWidth / 2), // Center of the grid cell\n        y: positionY + (row * cellHeight) + (cellHeight / 2), // Center of the grid cell\n        z: item.position.z // Assuming z-index remains constant or is managed elsewhere\n      };\n\n      // Update the entity's position using the game framework's method\n      this.game.updateEntity({ id: item.id, position: itemPosition }, {\n        skipAfterUpdateEntity: true\n      });\n\n      // console.log(`Item ${item.id} positioned at row ${row}, column ${col}`);\n    });\n\n    // console.log('adding item to container using grid layout algorithm');\n  }\n\n  //\n  // Layout container items using stack layout algorithm\n  //\n  if (layoutType === 'stack') {\n    // Define stack offset values\n    let stackOffsetX = 0; // Horizontal offset for each stacked item\n    let stackOffsetY = 5; // Vertical offset for each stacked item\n\n\n    // Retrieve the entity to be positioned\n    let entity = this.game.getEntity(entityId);\n\n    // Check if entity exists\n    if (!entity) {\n      console.error('Entity not found: ' + entityId);\n      return;\n    }\n\n    // TODO: we could add multiple ways to stack here by cardinal direction or custom function\n    // default stack top to bottom using entity size\n    stackOffsetY = entity.size.height + 5;\n\n\n    // Determine the stack position based on the number of items already in the container\n    let stackIndex = containerEnt.items.length - 1; // -1 because we've already added the new entityId to containerEnt.items\n\n    // Calculate the entity's new position based on stack index and offsets\n    let newPosition = {\n      x: containerPosition.x + stackIndex * stackOffsetX,\n      y: containerPosition.y + stackIndex * stackOffsetY,\n      z: containerPosition.z // Assuming z-index remains constant or is managed elsewhere\n    };\n\n    // Update the entity's position\n    this.game.updateEntity({ id: entityId, position: newPosition });\n\n    // Log for debugging purposes\n    console.log(`Entity ${entityId} stacked at index ${stackIndex} with position (${newPosition.x}, ${newPosition.y}, ${newPosition.z}) relative to container`);\n  }\n\n  //\n  // Layout container items using custom function\n  //\n  if (typeof layoutType === 'function') {\n    console.log('adding item to container using custom layout algorithm');\n    throw new Error('Custom layout algorithm functions are yet implemented!')\n  }\n\n}\n\nfunction applyFlexLayout(container, items, layoutConfig) {\n  const { flexDirection = 'row', justifyContent = 'flex-start', alignItems = 'center' } = layoutConfig;\n  const isRow = flexDirection.includes('row');\n  const mainSize = isRow ? 'width' : 'height';\n  const crossSize = isRow ? 'height' : 'width';\n  const mainStart = isRow ? 'x' : 'y';\n  const crossStart = isRow ? 'y' : 'x';\n\n  let mainAxisCurrentPosition = 0;\n  let crossAxisPosition = 0; // This can be adjusted for alignItems other than 'center'\n\n  for (const item of items) {\n    // Position each item along the main axis\n    item.position[mainStart] = mainAxisCurrentPosition;\n    // Adjust main axis position for the next item\n    mainAxisCurrentPosition += item.size[mainSize];\n\n    // Align items along the cross axis\n    switch (alignItems) {\n      case 'flex-start':\n        item.position[crossStart] = 0;\n        break;\n      case 'flex-end':\n        item.position[crossStart] = container.size[crossSize] - item.size[crossSize];\n        break;\n      case 'center':\n      default:\n        item.position[crossStart] = (container.size[crossSize] - item.size[crossSize]) / 2;\n        break;\n    }\n\n    // Update the entity's position in the game\n    this.game.updateEntity({ id: item.id, position: item.position });\n  }\n}\n\nfunction applyGridLayout(container, items, layoutConfig) {\n  const { gridTemplateColumns = '1fr', gridTemplateRows = '1fr' } = layoutConfig;\n  const cols = gridTemplateColumns.split(' ').length; // Simplified assumption\n  const rows = Math.ceil(items.length / cols);\n\n  const cellWidth = container.size.width / cols;\n  const cellHeight = container.size.height / rows;\n\n  items.forEach((item, index) => {\n    const col = index % cols;\n    const row = Math.floor(index / cols);\n\n    item.position.x = col * cellWidth;\n    item.position.y = row * cellHeight;\n\n    // Update the entity's position in the game\n    this.game.updateEntity({ id: item.id, position: item.position });\n  });\n}\n\n\n// Function to calculate the cumulative position of a container\nfunction getCumulativePosition(container) {\n  let position = { x: container.position.x, y: container.position.y, z: container.position.z };\n\n  if (!container.container) {\n    return position;\n  }\n  let parentContainer = game.getEntityByName(container.container); // Assuming there's a way to access the parent container\n\n  if (parentContainer) {\n    position.x += parentContainer.position.x;\n    position.y += parentContainer.position.y;\n    // Assuming z-index remains constant or is managed elsewhere, so not accumulating z\n    parentContainer = parentContainer.parent; // Move up to the next parent container\n  }\n\n  return position;\n}\n","// TODO: add support for Entity.items\n\nimport EntityClass from '../EntityClass.js'\n// TODO: remove TimersComponent import, use game reference instead ( reduce imported code )\n//import TimersComponent from '../../../Component/TimersComponent.js';\nimport ensureColorInt from './util/ensureColorInt.js';\nimport layoutEntity from './layoutEntity.js';\n\n\n\n\nfunction distanceSquared(x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  return dx * dx + dy * dy;\n}\n\nfunction deferEntityCreation(entityData) {\n  // Add entity data to a spatial data structure\n  spatialStructure.add(entityData);\n}\n\n// ignoreSetup set to true will ignore the setup phase of createEntity\n// the setup phase assigns default values to the entity and auto-id\n// this is currently being used from `rbush` plugin when creating deferred entities\nexport default function createEntity(config = {}, ignoreSetup = false) {\n  // console.log('createEntity', config)\n\n  let entityId;\n\n  // Remark: See: ./Game/Lifecyle.js for Mantra Lifecycle Hooks\n  // config = this.bp.lifecycle.triggerHook('before.createEntity', config);\n\n  if (!ignoreSetup) {\n    entityId = this._generateId();\n\n    let defaultConfig = {\n      id: entityId,\n      name: null,\n      kind: null,\n      body: true,\n      shape: 'triangle',\n      color: null,\n      position: { x: 0, y: 0, z: 0 },\n      startingPosition: null,\n      velocity: { x: 0, y: 0, z: 0 },\n      rotation: 0,\n      mass: 100,\n      density: 100,\n      health: Infinity,\n      score: 0,\n      // radius: null,\n      height: 16,\n      width: 16,\n      depth: 16,\n      // Remark: height, width, and depth are being replaced by size\n      size: { width: 100, height: 100, depth: 16 },\n      lifetime: null,\n      maxSpeed: 100,\n      isStatic: false,\n      isSensor: false,\n      restitution: 0,\n      container: null,\n      items: null,\n      sutra: null,\n      scene: [],\n      meta: null,\n      collectable: false,\n      hasInventory: true,\n      owner: 0, // 0 = server\n      source: null, // originating source of the entity, in most cases this is process id\n      inputs: null,\n      value: null,\n      destroyed: false,\n      type: 'NONE',\n      friction: 0.1,  // Default friction\n      frictionAir: 0.01, // Default air friction\n      frictionStatic: 0.5, // Default static friction\n      lockedProperties: null, // object hash of properties that should never be updated\n      actionRateLimiter: null, // object hash of state history\n      timers: null, // object hash timers for TimersComponent.js\n      yCraft: null, // object hash of properties for YCraft.js\n      text: null,\n      style: null,\n      texture: null,\n\n      collisionStart: true,\n      collisionActive: false,\n      collisionEnd: false,\n\n      pointerdown: false,\n      pointerup: false,\n      pointermove: false,\n      pointerover: false,\n      pointerout: false,\n      pointerenter: false,\n      pointerleave: false,\n\n      onDrop: null,\n      afterItemCollected: null,\n\n      afterRemoveEntity: null,\n      afterCreateEntity: null,\n      afterUpdate: null,\n      update: null,\n      exit: null,\n      ctick: this.bp.tick,\n      utick: this.bp.tick\n    };\n\n    // Remark: Adding support for new Entity.size prop, removing Entity.height and Entity.width\n    if (typeof config.size === 'object') {\n      config.width = config.size.width;\n      config.height = config.size.height;\n      config.depth = config.size.depth;\n    } else {\n      // Remark: Added 2/8/2024 Backwards support for legacy API, removed soon\n      config.size = { width: config.width, height: config.height, depth: config.depth };\n    }\n\n    // merge config with defaultConfig\n    config = { ...defaultConfig, ...config };\n\n    // before mutating any game state based on the incoming entity, we *must* check that certain properties validate\n    // check that position is well formed, contains, x,y,z, and is all valid numbers\n    if (config.position &&\n      (typeof config.position.x !== 'number' || isNaN(config.position.x) ||\n        typeof config.position.y !== 'number' || isNaN(config.position.y))) {\n      console.log('Entity.createEntity could not create with data', config);\n      throw new Error('Invalid position for entity');\n    }\n\n    /*\n    if (this.bp.systems.rbush) {\n      this.bp.systems.rbush.addEntity(config);\n    }\n    */\n\n    // Remark: Always add to deferredEntities, this is now being used to store all local\n    //         game data that may not yet be in the game.data scope ( off screen / not loaded )\n         // this.bp.deferredEntities[config.id.toString()] = config;\n    // TODO: add option for allowSpatialTreeToDefer to be set to false ( ignore FoV for certain ents )\n    \n    /*\n    if (this.bp.config.useFoV) {\n      // check to see if entity is within game.data.fieldOfView,\n      // if not, we will defer creation until it is\n      let currentPlayer = this.bp.getCurrentPlayer();\n      if (currentPlayer) {\n        let incomingPosition = config.position || { x: 0, y: 0, z: 0 };\n        let distance = distanceSquared(currentPlayer.position.x, currentPlayer.position.y, incomingPosition.x, incomingPosition.y);\n        let fieldOfViewSquared = this.bp.data.fieldOfView * this.bp.data.fieldOfView;\n        if (distance > fieldOfViewSquared) {\n          return;\n        }\n      }\n\n    }\n      */\n\n  }\n\n  entityId = config.id;\n  const entity = new EntityClass(entityId);\n\n  /*\n  entity.getTimer = (timerId) => {\n    return this.bp.components.timers.get(entityId, timerId);\n  };\n  */\n\n  if (!config.startingPosition) {\n    config.startingPosition = config.position;\n  }\n\n  const { name, type, kind, position, rotation, startingPosition, body, mass, density, velocity, isSensor, isStatic, lockedProperties, width, height, depth, size, radius, shape, color, maxSpeed, health, score, items, container, sutra, scene, meta, collectable, hasInventory, owner, source, inputs, value, lifetime, yCraft, text, style, texture, collisionActive, collisionStart, collisionEnd, pointerdown, pointerup, pointermove, pointerenter, pointerleave, pointerover, pointerout, onDrop, afterRemoveEntity, afterCreateEntity, afterUpdateEntity, afterItemCollected, update, exit, ctick, utick } = config;\n\n  let { x, y } = position;\n\n  /*\n  if (typeof config.position !== 'undefined') {\n    position.x = config.position.x;\n    position.y = config.position.y;\n  }\n  */\n\n  // asset that color is integer value\n  if (typeof color === 'string') {\n    // check to see if # is present, if so, convert hex to int\n    // needs to map common colors to integer values, red, green, black , etc\n  }\n\n  let ensuredColor = ensureColorInt(color);\n  \n  // console.log('position', position, 'width', width, 'height', height)\n  // Using game's API to add components\n  this.bp.addComponent(entityId, 'type', type || 'PLAYER');\n  this.bp.addComponent(entityId, 'name', name || null);\n  this.bp.addComponent(entityId, 'kind', kind);\n  this.bp.addComponent(entityId, 'position', position);\n  this.bp.addComponent(entityId, 'startingPosition', startingPosition);\n  this.bp.addComponent(entityId, 'velocity', velocity);\n  this.bp.addComponent(entityId, 'rotation', rotation);\n  this.bp.addComponent(entityId, 'mass', mass);\n  this.bp.addComponent(entityId, 'density', density);\n  this.bp.addComponent(entityId, 'health', health);\n  this.bp.addComponent(entityId, 'score', score);\n  this.bp.addComponent(entityId, 'width', width);\n  this.bp.addComponent(entityId, 'height', height);\n  this.bp.addComponent(entityId, 'depth', depth);\n  // Remark: height, width, and depth are being replaced by size\n  this.bp.addComponent(entityId, 'size', size);\n  this.bp.addComponent(entityId, 'radius', radius);\n  this.bp.addComponent(entityId, 'shape', shape);\n  this.bp.addComponent(entityId, 'color', ensuredColor);\n  this.bp.addComponent(entityId, 'maxSpeed', maxSpeed);\n  this.bp.addComponent(entityId, 'owner', owner);\n  // source is reversed in order to form the relationship between the source and the entity\n  this.bp.addComponent(source, 'source', source + '_' + entityId);\n  this.bp.addComponent(entityId, 'items', items);\n  this.bp.addComponent(entityId, 'scene', scene);\n\n  this.bp.addComponent(entityId, 'meta', meta);\n  this.bp.addComponent(entityId, 'collectable', collectable);\n  \n  // if entity is allowed to pickup items, add an inventory component\n  this.bp.addComponent(entityId, 'hasInventory', hasInventory);\n\n  this.bp.addComponent(entityId, 'value', value);\n\n  this.bp.addComponent(entityId, 'inputs', inputs);\n  this.bp.addComponent(entityId, 'lifetime', lifetime);\n  this.bp.addComponent(entityId, 'destroyed', false);\n  this.bp.addComponent(entityId, 'creationTime', Date.now());  // Current time in milliseconds\n  this.bp.addComponent(entityId, 'isSensor', isSensor);\n  this.bp.addComponent(entityId, 'isStatic', isStatic);\n  this.bp.addComponent(entityId, 'lockedProperties', lockedProperties);\n  this.bp.addComponent(entityId, 'actionRateLimiter', {});\n  // TODO: clean up API contract with Component\n      // this.bp.addComponent(entityId, 'timers', new TimersComponent('timers', entityId, this.bp));\n  this.bp.addComponent(entityId, 'yCraft', yCraft);\n  this.bp.addComponent(entityId, 'text', text);\n  this.bp.addComponent(entityId, 'style', style);\n  this.bp.addComponent(entityId, 'texture', texture);\n\n\n  this.bp.addComponent(entityId, 'afterItemCollected', afterItemCollected);\n\n\n  this.bp.addComponent(entityId, 'afterRemoveEntity', afterRemoveEntity);\n  this.bp.addComponent(entityId, 'afterCreateEntity', afterRemoveEntity);\n  this.bp.addComponent(entityId, 'afterUpdateEntity', afterUpdateEntity);\n\n\n  this.bp.addComponent(entityId, 'collisionActive', collisionActive);\n  this.bp.addComponent(entityId, 'collisionStart', collisionStart);\n  this.bp.addComponent(entityId, 'collisionEnd', collisionEnd);\n\n  this.bp.addComponent(entityId, 'pointerdown', pointerdown);\n  this.bp.addComponent(entityId, 'pointerup', pointerup);\n  this.bp.addComponent(entityId, 'pointermove', pointermove);\n  this.bp.addComponent(entityId, 'pointerenter', pointerenter);\n  this.bp.addComponent(entityId, 'pointerleave', pointerleave);\n  this.bp.addComponent(entityId, 'pointerover', pointerover);\n  this.bp.addComponent(entityId, 'pointerout', pointerout);\n\n  // Drag and Drop Events\n  this.bp.addComponent(entityId, 'onDrop', onDrop);\n\n  this.bp.addComponent(entityId, 'update', update);\n  this.bp.addComponent(entityId, 'exit', exit);\n  this.bp.addComponent(entityId, 'ctick', ctick);\n  this.bp.addComponent(entityId, 'utick', utick);\n\n  let _sutra;\n  // if the incoming sutra is an object, it is config object which needs to be scoped to the new entity\n  if (typeof sutra === 'object' && sutra !== null) {\n    if (typeof sutra.rules === 'function') {\n      if (typeof sutra.config !== 'object') {\n        sutra.config = {};\n      }\n      // if there is a valid rules function, we will create the Sutra instance\n      // it is assumed the signature of the rules function is (game, entityId, config)\n      // this may change in the future\n      _sutra = sutra.rules(this.bp, entityId, sutra.config);\n    } else {\n      // could be a Sutra instance object instance without config object\n      _sutra = sutra;\n    }\n  } else {\n    // the incoming sutra was not a non-null object\n    // it could be null or a function, assign component value without modification\n    _sutra = sutra;\n  }\n\n  this.bp.addComponent(entityId, 'sutra', _sutra);\n\n  if (body) {\n    // remove this step, have everything work in addToWorld\n    let body = {\n      entityId: entityId,\n      width: width,\n      height: height,\n      radius: radius,\n      type: type,\n      shape: shape,\n      position: position,\n      velocity: velocity,\n      rotation: rotation,\n      mass: mass,\n      density: density,\n      isStatic: isStatic,\n      isSensor: isSensor,\n      restitution: config.restitution,\n      friction: config.friction,\n      frictionAir: config.frictionAir,\n      frictionStatic: config.frictionStatic\n    }\n    body.myEntityId = entityId; // TODO myEntityId is legacy, remove\n\n    /* Disabled physics for now\n    this.bp.physics.addToWorld(body);\n    // TODO: bodyMap needs to be removed\n    //       in order to decouple physics from game, we'll need to use body references in app space\n    //       and allow the physics interface to use entity.id as the key between worker and app space\n    // this.bp.bodyMap[entityId] = body;\n\n    if (velocity && (velocity.x !== 0 || velocity.y !== 0)) {\n      this.bp.physics.setVelocity(entityId, velocity);\n    }\n\n    if (position) {\n      this.bp.physics.setPosition(entityId, position);\n    }\n    if (typeof rotation !== 'undefined') {\n      if (this.bp.physics && this.bp.physics.setRotation) {\n        this.bp.physics.setRotation(entityId, rotation);\n      }\n    }\n      */\n  } else {\n    // immediately add to changedEntities\n    // this.bp.changedEntities.add(entityId);\n  }\n\n  // Add the entity to the game entities scope\n  // TODO: new Entity() should do this\n  // console.log('setting id', entityId, 'to entity')\n  this.bp.entities.set(entityId, {\n    id: entityId\n  });\n  // console.log(\"SETTING CHANGED\", entityId)\n  // this.bp.changedEntities.add(entityId);\n\n  // get updated entity with components\n  let updatedEntity = this.bp.getEntity(entityId);\n\n  if (typeof updatedEntity.pendingRender === 'undefined') {\n    updatedEntity.pendingRender = {};\n  }\n  \n  /*\n  this.bp.graphics.forEach(function (graphicsInterface) {\n    updatedEntity.pendingRender[graphicsInterface.id] = true;\n  });\n  */\n\n  // updates entity in the ECS entity Map scope\n  this.bp.entities.set(entityId, updatedEntity);\n\n  // TODO: move this to separate file\n  if (container) {\n    this.layoutEntity(container, entityId);\n  }\n\n  // updates entity in the flat game.data scope\n  this.bp.data.ents = this.bp.data.ents || {};\n  this.bp.data.ents._ = this.bp.data.ents._ || {};\n  this.bp.data.ents._[entityId] = updatedEntity;\n  this.bp.data.ents[updatedEntity.type] = this.bp.data.ents[updatedEntity.type] || [];\n  this.bp.data.ents[updatedEntity.type].push(updatedEntity);\n\n  // check to see if there are no active players, if so set the entity as the current player\n  // TODO: config flag\n  if (updatedEntity.type === 'PLAYER' && this.bp.data.ents.PLAYER) {\n    let activePlayerCount = Object.keys(this.bp.data.ents.PLAYER).length;\n    // console.log(\"activePlayerCount\", activePlayerCount)\n    if (activePlayerCount < 1) {\n      // console.log('Setting player id', entityId);\n      this.bp.setPlayerId(entityId);\n    }\n  }\n\n  //\n  // Entity Lifecycle afterCreateEntity\n  //\n  let _afterCreateEntity;\n  if (typeof config.afterCreateEntity === 'function') {\n    _afterCreateEntity = config.afterCreateEntity;\n  }\n  if (_afterCreateEntity) {\n    _afterCreateEntity(config);\n  }\n\n  //\n  //\n  // Game Lifecycle after.createEntity\n  // updatedEntity = this.bp.lifecycle.triggerHook('after.createEntity', config);\n\n  return updatedEntity;\n}","export default function getEntity(entityId) {\n    \n  if (typeof entityId === 'string') {\n    entityId = parseInt(entityId); // for now, this can be removed when we switch Component.js to use Maps\n  }\n\n  if (!this.bp.entities.has(entityId)) {\n    return null;\n  }\n\n  const entity = {};\n\n  // Iterate over all registered components and fetch their data if available\n  for (const componentType in this.bp.components) {\n    let componentData = this.bp.getComponent(entityId, componentType);\n    if (typeof componentData !== 'undefined' && componentData !== null) {\n      entity[componentType] = componentData;\n    }\n  }\n\n  if (Object.keys(entity).length === 0) {\n    return null;\n  }\n\n  entity.id = entityId;\n\n  return entity;\n\n}","export default function inflateEntity(entityData) {\n  let game = this.game;\n\n  // Check for entity marked for destruction and remove immediately if so\n  if (entityData.destroyed === true) {\n    game.removeGraphic(entityData.id);\n    game.removeEntity(entityData.id);\n    return;\n  }\n\n  // Check for entities marked for local removal, skip updates if found\n  if (game.removedEntities.has(entityData.id)) {\n    console.log('Skipping update for locally removed entity:', entityData.id);\n    return;\n  }\n\n  // Check if the entity is from a remote source and handle potential source conflicts\n  if (entityData.source != null) {\n    // This entity orginated from a remote source, we'll need to account for an entity.id that was\n    // created in another system\n    let existingSourceId = game.components.source.get(entityData.source + '-' + entityData.id); // get concat source-id\n    // If a prior source exists, we should perform an update using the sourceId\n    // If the entity exists and has a different source, log the conflict and decide on handling strategy\n    if (existingSourceId) { // sourceId?\n      // console.log(`Entity ${entityData.id} from source ${entityData.source} encountered, previously associated with source ${existingSource}. Handling potential ID conflict.`);\n      // Implement conflict resolution strategy here, e.g., update, replace, ignore, etc.\n      entityData.id = entityData.source.split('_')[1]; // Remark brittle, maybe sourceId\n      // console.log(\"ALREADY EXISTS updateOrCreate REMOTE\", entityData);\n      return updateOrCreate(game, entityData);\n    } else {\n      delete entityData.id;\n      // store a new source refer\n\n      // since this ent is remote, we should attempt to build it by type,\n      // in order to re-establish the correct components and behaviors\n      let type = entityData.type;\n      if (type) {\n\n        // tolowercase then uppercase first letter\n        type = type.toLowerCase();\n        type = type.charAt(0).toUpperCase() + type.slice(1);\n\n        try {\n          let defaultTypeConfig = this.game.make();\n          defaultTypeConfig[type](entityData);\n          let config = defaultTypeConfig.build();\n          // merge the default type config with the entity data\n          for (let p in config) {\n            entityData[p] = config[p];\n          }\n          // remove any undefined values or null values\n          for (let p in entityData) {\n            if (typeof entityData[p] === 'undefined' || entityData[p] === null) {\n              delete entityData[p];\n            }\n          }\n        }\n        catch (err) {\n          // This will happen for any type that is not defined by an active plugin\n          // console.warn('Failed to build remote entity by type:', type, err, 'using default build');\n          defaultBuild(game, entityData);\n        }\n\n        // console.log('proceeding with typed data', entityData)\n\n      } else {\n        defaultBuild(game, entityData);\n      }\n      // console.log('built ent with data', entityData)\n      return updateOrCreate(game, entityData);\n    }\n  } else {\n    return updateOrCreate(game, entityData);\n  }\n\n}\n\nfunction defaultBuild(game, entityData) {\n  // console.log('defaultBuild', entityData.type)\n  // merge default build make \n  let defaultConfig = game.make().build();\n  for (let p in defaultConfig) {\n    if (typeof entityData[p] === 'undefined' || entityData[p] === null) {\n      entityData[p] = defaultConfig[p];\n    }\n  }\n  // remove any undefined values or null values ( should not be necessary at this stage ) ( more tests )\n  // console.log('inflateENtity defaultBuild got data', entityData)\n\n  // Why though???? This could be a real problem with peer to peer data\n  // There would technically be no way of stopping while(true) alert('hello') from being sent\n  // Better to not allow custom events to be sent / inflated\n  // This means that only pre-defined shared objects can be sent\n  // Such that the events are known and can be handled / cannot be custom\n  let supportedSerializedEvents = ['collisionStart']; // TODO: add all events with tests\n\n  for (let p in entityData) {\n\n    if (supportedSerializedEvents.includes(p)) {\n      // this is a serialized function, create a new function from the string and assign it to the entity\n      // console.log('inflateEntity serialized function', entityData.type, entityData[p], entityData);\n      // this is a function that had .toSTring() called on it, we need to re-create the function\n      try {\n        // Remark: This try/catch is not gaurenteed to catch all eval() errors\n        entityData[p] = eval('(' + entityData[p] + ')');\n      } catch (err) {\n        console.log('Failed to inflate serialized function', entityData.type, entityData[p], entityData, err)\n      }\n      //console.log(\"after inflateENtity seralize fn\", entityData[p])\n    }\n\n    if (typeof entityData[p] === 'undefined' || entityData[p] === null) {\n      delete entityData[p];\n    }\n  }\n}\n\nfunction updateOrCreate(game, entityData) {\n  // After handling potential source conflicts, proceed to create or update the entity\n  let localEntity = game.entities.get(entityData.id);\n  if (!localEntity) {\n    // If it's a new entity or a remote entity not seen before, create it\n    //console.log(\"createEntity LOCAL\", entityData);\n    return game.createEntity(entityData);\n  } else {\n    //console.log(\"updateEntity LOCAL\", entityData);\n    // If it's an existing entity, update it\n    return game.updateEntity(entityData);\n  }\n\n}","// TODO: double check that all components values are being cleared on removal of ent\nexport default function removeEntity(entityId, removeFromGameData = true) {\n\n  let ent = this.game.entities.get(entityId);\n\n  if (!ent) {\n    return;\n  }\n\n  let _afterRemoveEntity;\n\n  if (typeof ent.afterRemoveEntity === 'function') {\n    _afterRemoveEntity = ent.afterRemoveEntity;\n  }\n\n  let canBeRemoved = this.game.lifecycle.triggerHook('before.removeEntity', ent);\n\n  if (canBeRemoved === false) {\n    return;\n  }\n\n  if (ent && this.game.systems.graphics && ent.graphics) {\n    // Is this best done here? or in the graphics plugin?\n    this.game.systems.graphics.removeGraphic(entityId);\n  }\n  if (ent) {\n    this.game.components.destroyed.set(entityId, true);\n\n    // check to see if any timers exist, if so clear them all\n    if (this.game.components.timers.get(entityId)) {\n      let timers = this.game.components.timers.get(entityId);\n      for (let timerId in timers.timers) {\n        timers.removeTimer(timerId);\n      }\n    }\n\n    // update the entity with the destroyed state\n    let updatedEntity = this.game.getEntity(entityId);\n    this.game.entities.set(entityId, updatedEntity);\n\n    if (updatedEntity) {\n      // actually remove the entity from the game world\n      // will be set to false for field of view related removals\n      if (removeFromGameData) {\n        if (this.game.systems.rbush) {\n          this.game.systems.rbush.removeEntity(updatedEntity);\n        }\n        delete this.game.deferredEntities[entityId];\n      }\n    }\n\n  }\n\n  if (_afterRemoveEntity) {\n    _afterRemoveEntity(ent);\n  }\n  this.game.lifecycle.triggerHook('after.removeEntity', ent);\n\n}","import ensureColorInt from './util/ensureColorInt.js';\n\nexport default function updateEntity(entityDataOrId, entityData, updateOptions = {}) {\n\n  if (typeof entityDataOrId === 'string' || typeof entityDataOrId === 'number') {\n    entityData = { id: entityDataOrId, ...entityData };\n  } else {\n    entityData = entityDataOrId;\n  }\n\n  // Remark: See: ./Game/Lifecyle.js for Mantra Lifecycle Hooks\n  entityData = this.game.lifecycle.triggerHook('before.updateEntity', entityData);\n\n  if (entityData == null) {\n    console.warn('updateEntity was not provided a valid entityData', entityData);\n    console.warn('This is most likely the result of passing invalid data to updateEntity()');\n    return;\n  }\n\n  // console.log('updateEntity', entityData)\n  let entityId = entityData.id;\n  if (typeof entityId === 'undefined') {\n    // check to see if we have a name, if so, find the entity by name\n    if (entityData.name) {\n      let ent = this.game.getEntityByName(entityData.name);\n      if (ent) {\n        entityId = ent.id;\n      }\n    }\n  }\n\n  if (typeof entityId === 'undefined') {\n    console.log('Error: updateEntity was not provided a valid entity.id or entity.name', entityData);\n    console.log('This is most likely the result of passing invalid data to updateEntity()');\n    return;\n  }\n\n  let ent = this.game.getEntity(entityId);\n\n  // if the state doesn't exist, return error\n  if (!ent) {\n    //console.log('Error: updateEntity called for non-existent entity', entityId, entityData);\n    //console.log('This should not happen, if a new state came in it should be created');\n    return;\n  }\n\n  // Remove destroyed entities\n  if (entityData.destroyed) {\n    this.removeEntity(entityId);\n    return;\n  }\n\n  // not a component property yet, just ad-hoc on client\n  ent.pendingRender = {};\n  this.game.graphics.forEach(function (graphicsInterface) {\n    ent.pendingRender[graphicsInterface.id] = true;\n  });\n\n  if (entityData.color) {\n    // entityData.color may be color name as string, hex code, or integer value\n    // ensureColorInt will convert incoming color to safe integer value\n    //console.log('entityData.color', entityData.color)\n    let ensuredColor = ensureColorInt(entityData.color);\n    // console.log('ensuredColor', ensuredColor)\n    this.game.components.color.set(entityId, ensuredColor);\n  }\n\n  let updateSize = false;\n  if (entityData.height) {\n    updateSize = true;\n    this.game.components.height.set(entityId, entityData.height);\n  }\n\n  if (entityData.width) {\n    updateSize = true;\n    this.game.components.width.set(entityId, entityData.width);\n  }\n\n  if (entityData.radius) {\n    updateSize = true;\n    // this.game.components.radius.set(entityId, entityData.radius);\n  }\n\n  // size is new API, remove root level height, width, radius\n  if (entityData.size) {\n    updateSize = true;\n    this.game.components.size.set(entityId, entityData.size);\n  }\n\n  /*\n  if (entityData.body === false) {\n    // alert(\"remove body\");\n    this.game.physics.removeBody(entityId);\n  }\n  */\n\n  if (updateSize) {\n    // let body = this.game.bodyMap[entityId];\n    this.game.physics.setBodySize(entityId, entityData);\n\n  }\n\n  if (entityData.position) {\n\n    // update the position\n    this.game.components.position.set(entityId, entityData.position);\n\n    // let body = this.game.bodyMap[entityId];\n    this.game.physics.setPosition(entityId, entityData.position);\n\n  }\n\n  if (entityData.velocity) {\n    this.game.physics.setVelocity(entityId, entityData.velocity);\n  }\n\n  if (entityData.health) {\n    this.game.components.health.set(entityId, entityData.health);\n  }\n\n  if (typeof entityData.thickness !== 'undefined' && entityData.thickness !== null) {\n    this.game.components.width.set(entityId, entityData.thickness);\n  }\n\n  //\n  // Event handlers / Lifecycle Events\n  //\n\n  //\n  // Entity event lifecycle events will merge by default ( for now )\n  if (typeof entityData.update !== 'undefined') {\n    // get the current component value\n    let currentFn = this.game.components.update.get(entityId);\n    let entRef = this.game.data.ents._[entityId];\n    if (entRef) {\n      // clear out all existing update functions\n      // TODO: add better mappings in EntityBuilder.js for granular removals\n      if (entityData.update === null) {\n        this.game.components.update.set(entityId, null);\n      } else {\n        // create a quick config to store the events, we'll want to convert entire function to use this\n        let updateConfig = this.game.make();\n        updateConfig.onUpdate(entityData.update);\n        // inherit the current update function, creates a tree of functions\n        // do we want to do this? what are the implications?\n        if (currentFn && currentFn.handlers && currentFn.handlers.length) {\n          currentFn.handlers.forEach(function (fn) {\n            // console.log(\"adding existing fn to updateConfig\", fn.toString())\n            updateConfig.onUpdate(fn);\n          });\n        }\n        // console.log(\"new updateConfig\", updateConfig.config.update)\n        // Update the current ent that will be returned from updateEntity(entityId, entityData)\n        ent.update = updateConfig.config.update;\n        // Update the component value\n        this.game.components.update.set(entityId, updateConfig.config.update);\n      }\n    }\n  }\n\n  //\n  // UI Component Properties\n  //\n  if (typeof entityData.value !== 'undefined') {\n    this.game.components.value.set(entityId, entityData.value);\n  }\n\n  //\n  // Meta properties\n  //\n  if (typeof entityData.meta !== 'undefined') {\n    let merged = {};\n    let componentData = this.game.components.meta.get(entityId);\n    if (componentData) {\n      merged = { ...componentData, ...entityData.meta };\n    } else {\n      merged = entityData.meta;\n    }\n    this.game.components.meta.set(entityId, merged);\n  }\n\n  if (typeof entityData.score !== 'undefined' && entityData.score !== null) {\n    this.game.components.score.set(entityId, entityData.score);\n  }\n\n  if (typeof entityData.rotation !== 'undefined') {\n    if (this.game.physics && this.game.physics.setRotation) {\n      // let body = this.game.bodyMap[entityId];\n      this.game.physics.setRotation(entityId, entityData.rotation);\n\n    } else {\n      console.log('WARNING: physics.setRotation is not defined');\n      // Remark: we could support direct rotation updates here if mantra was being run without physics engine\n      // this.game.components.rotation.set(entityId, entityData.rotation);\n    }\n  }\n\n  if (typeof entityData.text !== 'undefined') {\n    this.game.components.text.set(entityId, entityData.text);\n  }\n\n  // Items\n  if (typeof entityData.items !== 'undefined') {\n    // overwrite all items ( for now )\n    // Remark: in the future we could merge instead of overwrite\n    this.game.components.items.set(entityId, entityData.items);\n  }\n\n  // Sutra rules\n  if (typeof entityData.sutra !== 'undefined') {\n    // overwrite sutra ( for now )\n    this.game.components.sutra.set(entityId, entityData.sutra);\n  }\n\n  // Items\n  if (typeof entityData.items !== 'undefined') {\n    // overwrite all items ( for now )\n    // Remark: in the future we could merge instead of overwrite\n    this.game.components.items.set(entityId, entityData.items);\n  }\n\n  if (typeof entityData.style !== 'undefined') {\n    // overwrite all items ( for now )\n    // Remark: in the future we could merge instead of overwrite\n    this.game.components.style.set(entityId, entityData.style);\n  }\n\n  if (typeof entityData.texture !== 'undefined') {\n    // overwrite all items ( for now )\n    // Remark: in the future we could merge instead of overwrite\n    // create new textures object by merging in the new texture\n    let prev = this.game.components.texture.get(entityId);\n    let newTexture;\n    // check to see if incoming entityData.texture is a string, if so, it's a texture id\n    if (typeof entityData.texture === 'string') {\n      newTexture = entityData.texture;\n    } else {\n      newTexture = { ...prev, ...entityData.texture };\n    }\n\n    this.game.components.texture.set(entityId, newTexture);\n  }\n\n  // Remark: The physics engine update will update the position\n  //         If we update the position here, it's most likely going to be overwritten by the physics engine\n  if (this.game.systems.rbush) {\n    // this.game.systems.rbush.updateEntity(ent);\n  }\n\n  // Updates the Entity.utick\n  this.game.components.utick.set(entityId, this.game.tick);\n\n  //\n  // Entity Lifecycle afterUpdateEntity\n  //\n\n  let updatedEnt = this.game.getEntity(entityId);\n\n  if (updateOptions.skipAfterUpdateEntity !== true) {\n    let _afterUpdateEntity;\n\n    if (typeof updatedEnt.afterUpdateEntity === 'function') {\n      _afterUpdateEntity = updatedEnt.afterUpdateEntity;\n    }\n    if (_afterUpdateEntity) {\n      _afterUpdateEntity(updatedEnt);\n    }\n  }\n\n  updatedEnt = this.game.lifecycle.triggerHook('after.updateEntity', updatedEnt);\n\n  return updatedEnt;\n\n}\n\n/* TODO: we need to iterate all events for composite updates\n   TODO: add unit tests for Entity.updateEntity({ eventName }) tests\n         be sure to check all cases\n         double check our usage of using null to pop fn from array\n         see about exact fn match for removal\n\nfunction updateEntityEvents(entityId, entityData) {\n  console.log(\"Updating Entity Events\");\n\n  // List of known event names\n  const eventNames = [\n    'pointerdown', 'pointerup', 'pointermove', 'pointerover', 'pointerout',\n    'pointerenter', 'pointerleave', 'collisionStart', 'collisionActive',\n    'collisionEnd', 'onDrop', 'update', 'afterRemoveEntity'\n  ];\n\n  let entRef = this.game.data.ents._[entityId];\n  if (!entRef) {\n    console.log(\"Entity reference not found\");\n    return;\n  }\n\n  eventNames.forEach(eventName => {\n    if (typeof entityData[eventName] !== 'undefined') {\n      console.log(`Processing ${eventName}`);\n\n      // Create a quick config to store the events\n      let eventConfig = this.game.make();\n\n      // Add the new event handler\n      eventConfig['_addEventHandler'](eventName, entityData[eventName]);\n\n      // Check if there are existing event handlers to preserve\n      let existingEventFn = this.game.components[eventName].get(entityId);\n      if (typeof existingEventFn === 'function' && Array.isArray(existingEventFn.handlers)) {\n        // Add each existing handler to the new configuration to preserve them\n        existingEventFn.handlers.forEach(handler => eventConfig['_addEventHandler'](eventName, handler));\n      }\n\n      // Set the updated configuration\n      this.game.components[eventName].set(entityId, eventConfig.config[eventName]);\n    }\n  });\n}\n*/","export default function removeAllEntities(options) {\n\n  // curry arguments, legacy API\n  let clearCurrentPlayer = false;\n  let excludeByName = [];\n  if (typeof options === 'boolean') {\n    clearCurrentPlayer = options;\n  }\n\n  if (typeof options === 'object' && Array.isArray(options.excludeByName)) {\n    excludeByName = options.excludeByName;\n  }\n\n  if (this.game.data.ents) {\n    for (let eId in this.game.data.ents._) {\n      let ent = this.game.data.ents._[eId];\n      // Do not remove the current player if clearCurrentPlayer is false\n      if (ent.id === this.game.currentPlayerId && !clearCurrentPlayer) {\n        continue;\n      }\n      // Do not remove entities that are excluded by name\n      if (excludeByName.includes(ent.name)) {\n        continue;\n      }\n      if (ent && ent.yCraft && ent.yCraft.part && ent.yCraft.part.unload) {\n        ent.yCraft.part.unload();\n      }\n      this.game.removeEntity(ent.id);\n    }\n  \n    if (clearCurrentPlayer) {\n      this.game.currentPlayerId = null;\n    }\n\n  }\n\n}","// Entity.js - Marak Squires 2023\nimport createEntity from './lib/createEntity.js';\nimport getEntity from './lib/getEntity.js';\nimport inflateEntity from './lib/inflateEntity.js';\nimport removeEntity from './lib/removeEntity.js';\nimport updateEntity from './lib/updateEntity.js';\nimport layoutEntity from './lib/layoutEntity.js';\nimport removeAllEntities from './lib/removeAllEntities.js';\n\nclass Entity {\n\n  static id = 'entity';\n  static removable = false;\n\n  constructor() {\n    this.id = Entity.id;\n    this.nextEntityId = 1; // 0 is reserved for server\n  }\n\n  init(bp) {\n\n    // bind game scope to this.bp\n    // TODO: game scope now becomes bp scope\n    this.bp = bp;\n\n    // init a new Map to store entities\n    bp.entities = new Map();\n\n    // does Entity need to register as a system?\n    // systems really only care about update() and maybe render()\n    // i think Entity proper doesn't care, only instances that are build will need to register?\n    // will have to double check and see\n    // this.bp.systemsManager.addSystem(this.id, this);\n\n    // Bind some methods to parent Game scope for convenience\n    // The most useful and common System methods are expected to be bound to Game\n    // This allows developers to customcraft a clean Game API based on their needs\n    this.bp.createEntity = createEntity.bind(this);\n    this.bp.getEntity = getEntity.bind(this);\n    this.bp.removeEntity = removeEntity.bind(this);\n    this.bp.getEntityByName = this.getEntityByName.bind(this);\n    this.bp.getEntities = this.allEntities.bind(this);\n    this.bp.updateEntity = updateEntity.bind(this);\n    this.bp.inflateEntity = inflateEntity.bind(this);\n    this.bp.hasEntity = this.hasEntity.bind(this);\n    this.bp.findEntity = this.findEntity.bind(this);\n    this.bp.removeAllEntities = removeAllEntities.bind(this);\n    this.removeAllEntities = removeAllEntities.bind(this);\n    this.layoutEntity = layoutEntity.bind(this);\n  }\n\n  hasEntity (entityId) {\n    return this.bp.entities.has(entityId);\n  }\n\n  findEntity (query) {\n    if (typeof query === 'string') {\n      query = { name: query };\n    }\n    // iterate over entities and return the first match\n    for (let [entityId, entity] of this.bp.entities) {\n      let match = true;\n      for (let key in query) {\n        if (entity[key] !== query[key]) {\n          match = false;\n          break;\n        }\n      }\n      if (match) {\n        return entity;\n      }\n    }\n  }\n\n  getEntityByName(name) {\n    for (let [entityId, entity] of this.bp.entities) {\n      if (entity.name === name) {\n        return entity;\n      }\n    }\n  }\n \n  _generateId() {\n    return this.nextEntityId++;\n  }\n\n  cleanupDestroyedEntities() {\n\n    this.bp.lifecycle.triggerHook('before.cleanupRemovedEntities');\n\n    const destroyedComponentData = this.bp.components.destroyed.data;\n    for (let entityId in destroyedComponentData) {\n      if (typeof entityId === 'string') {\n        entityId = parseInt(entityId); // for now, this can be removed when we switch Component.js to use Maps\n      }\n      const destroyedType = this.bp.components.type.get(entityId);\n      if (destroyedComponentData[entityId]) {\n        // Removes the body from the physics engine\n        if (typeof this.bp.physics.removeBody === 'function') {\n          this.bp.physics.removeBody(entityId);\n        }\n        // Delete associated components for the entity using Component's remove method\n        for (let componentType in this.bp.components) {\n          this.bp.components[componentType].remove(entityId);\n        }\n        this.bp.entities.delete(entityId);\n        // remove the reference in this.bp.data.ents\n        delete this.bp.data.ents._[entityId];\n        // find entity by id and filter it out\n        if (this.bp.data.ents[destroyedType]) {\n          // TODO: missing test ^^^\n          this.bp.data.ents[destroyedType] = this.bp.data.ents[destroyedType].filter((entity) => {\n            return Number(entity.id) !== Number(entityId);\n          });\n        }\n      }\n    }\n\n    this.bp.lifecycle.triggerHook('after.cleanupRemovedEntities');\n\n  }\n\n  // Update the getEntities method to return the game.entities\n  allEntities() {\n    return this.bp.entities;\n  }\n\n\n  applyLockedProperties(entityId, lockedProperties) {\n    // Check and apply locked properties\n    if (lockedProperties) {\n      console.log(\"Processing lockedProperties properties\");\n      for (let key in lockedProperties) {\n        let currentVal = this.bp.components[key].get(entityId);\n        console.log('currentVal', currentVal, 'key', key, lockedProperties)\n        if (currentVal !== undefined && currentVal !== null) {\n          if (typeof lockedProperties[key] === 'object' && !Array.isArray(lockedProperties[key])) {\n            // If lockedProperties[key] is an object, iterate through its keys\n            console.log('lockedProperties[key]', lockedProperties[key])\n            for (let subKey in lockedProperties[key]) {\n              console.log('subKey', subKey, lockedProperties[key][subKey])\n              if (lockedProperties[key][subKey] === true) {  // only process if the value is true\n                let nestedVal = currentVal[subKey];\n                if (nestedVal !== undefined && nestedVal !== null) {\n                  console.log('Setting lockedProperties property', `${key}.${subKey}`, 'to', nestedVal);\n                  this.bp.components['lockedProperties'].set(entityId, { [key]: { [subKey]: nestedVal } });\n                } else {\n                  console.log('Error: No such component or invalid value for', `${key}.${subKey}`);\n                }\n              }\n            }\n          } else if (lockedProperties[key] === true) {  // if lockedProperties[key] is not an object and the value is true\n            console.log('Setting lockedProperties property', key, 'to', currentVal);\n            this.bp.components['lockedProperties'].set(entityId, { [key]: currentVal });\n          }\n        } else {\n          console.log('Error: No such component or invalid value for', key);\n        }\n      }\n    }\n  }\n\n}\n\nexport default Entity;\n\n/* refactor to use this pattern */\n/*\nimport Entity from './Entity.js';\nconst entity = new Entity(entityId);\n\n*/\n","// Component.js - Marak Squires 2023\nclass Component {\n    constructor(name, game) {\n      this.name = name;\n      this.data = {};\n      this.game = game;\n    }\n  \n    set(key, value) {\n      const entityId = Array.isArray(key) ? key[0] : key;\n  \n      // Check if the property is locked\n      if (this.game) {\n        // console.log('this.game', this.game)\n        /*\n        const lockedProps = this.game.components['lockedProperties'].get(entityId);\n        if (this.isLocked(lockedProps, this.name)) {\n          // console.log(`Property ${key} is locked and cannot be updated.`);\n          return; // Do not update if the property is locked\n        }\n          */\n      }\n  \n      if (Array.isArray(key)) {\n        // Ensure nested structure exists\n        let current = this.data;\n        for (let i = 0; i < key.length - 1; i++) {\n          if (!current[key[i]]) {\n            current[key[i]] = {};\n          }\n          current = current[key[i]];\n        }\n        current[key[key.length - 1]] = value;\n      } else {\n        this.data[key] = value;\n      }\n  \n      // After setting the value, update the corresponding entity in the game.entities\n      if (this.game && this.game.entities && this.game.entities.has(entityId)) {\n        let existing = this.game.entities.get(entityId);\n        existing[this.name] = this.get(entityId);\n      }\n  \n    }\n  \n    get(key) {\n      if (Array.isArray(key)) {\n        let current = this.data;\n        for (let i = 0; i < key.length; i++) {\n          if (current[key[i]] === undefined) {\n            return null;\n          }\n          current = current[key[i]];\n        }\n        return current;\n      }\n  \n      if (typeof this.data[key] === 'undefined' || this.data[key] === null) {\n        return null;\n      }\n  \n      return this.data[key];\n    }\n  \n    remove(key) {\n      if (Array.isArray(key)) {\n        let current = this.data;\n        for (let i = 0; i < key.length - 1; i++) {\n          if (current[key[i]] === undefined) {\n            return;\n          }\n          current = current[key[i]];\n        }\n        delete current[key[key.length - 1]];\n      } else {\n        delete this.data[key];\n      }\n  \n    }\n  \n    // Helper method to check if a property or sub-property is locked\n    isLocked(lockedProps, key) {\n      if (!lockedProps) return false;\n  \n      if (Array.isArray(key)) {\n        let current = lockedProps;\n        for (let i = 0; i < key.length; i++) {\n          if (current[key[i]] === undefined) {\n            return false; // Property not locked\n          }\n          current = current[key[i]];\n        }\n        return true; // Property is locked\n      }\n  \n      return lockedProps[key] !== undefined;\n    }\n  \n  }\n  \n  export default Component;","import EntityClass from './EntityClass.js';\nimport Component from './Component.js';\n\nexport default class Entity {\n    constructor(bp, options = {}) {\n        this.bp = bp;\n        this.bp.components = {};\n        this.bp.addComponent = this.addComponent.bind(this);\n        this.bp.getComponent = this.getComponent.bind(this);\n\n        let _entity = new EntityClass(bp, options);\n        _entity.init(bp);\n        console.log('Entity created', _entity);\n\n\n        return this;\n    }\n\n    async init() {\n\n\n        return 'loaded entity';\n    }\n\n    addComponent(entityId, componentType, data) {\n\n        if (!this.bp.components[componentType]) {\n          this.bp.components[componentType] = new Component(componentType, this.bp);\n        }\n        // Initialize an empty map for the actionRateLimiter component\n        // TODO: remove this hard-coded check for actionRateLimiter\n        if (componentType === 'actionRateLimiter') {\n          data = new Map();\n        }\n    \n        if (data == null) {\n          return;\n        }\n    \n        this.bp.components[componentType].set(entityId, data);\n      }\n\n      getComponent(entityId, componentType) {\n        if (this.bp.components.hasOwnProperty(componentType)) {\n          return this.bp.components[componentType].get(entityId);\n        }\n        return null;\n      }\n    \n    \n}\n"],"names":["ensureColorInt","color","colorNameToHex","red","green","blue","black","white","yellow","purple","orange","pink","indigo","violet","startsWith","parseInt","replace","toLowerCase","console","error","layoutEntity","container","entityId","containerEnt","this","game","findEntity","Error","containerPosition","position","x","y","z","layoutType","origin","style","layout","meta","items","push","flexConfig","flex","map","itemId","getEntity","applyFlexLayout","call","gridConfig","grid","applyGridLayout","entity","offsetX","offsetY","size","width","height","cumulativeContainerPosition","newPosition","updateEntity","id","cols","columns","rows","log","containerItems","containerSize","cellWidth","cellHeight","forEach","item","index","row","Math","floor","col","positionX","positionY","itemPosition","skipAfterUpdateEntity","stackOffsetX","stackOffsetY","stackIndex","length","layoutConfig","flexDirection","justifyContent","alignItems","isRow","includes","mainSize","crossSize","mainStart","crossStart","mainAxisCurrentPosition","gridTemplateColumns","gridTemplateRows","split","ceil","createEntity","config","ignoreSetup","_generateId","defaultConfig","name","kind","body","shape","startingPosition","velocity","rotation","mass","density","health","Infinity","score","depth","lifetime","maxSpeed","isStatic","isSensor","restitution","sutra","scene","collectable","hasInventory","owner","source","inputs","value","destroyed","type","friction","frictionAir","frictionStatic","lockedProperties","actionRateLimiter","timers","yCraft","text","texture","collisionStart","collisionActive","collisionEnd","pointerdown","pointerup","pointermove","pointerover","pointerout","pointerenter","pointerleave","onDrop","afterItemCollected","afterRemoveEntity","afterCreateEntity","afterUpdate","update","exit","ctick","bp","tick","utick","isNaN","radius","afterUpdateEntity","_sutra","ensuredColor","addComponent","Date","now","rules","entities","set","_afterCreateEntity","updatedEntity","pendingRender","data","ents","_","PLAYER","Object","keys","setPlayerId","has","componentType","components","componentData","getComponent","inflateEntity","entityData","removeGraphic","removeEntity","removedEntities","get","updateOrCreate","charAt","toUpperCase","slice","defaultTypeConfig","make","build","p","err","defaultBuild","supportedSerializedEvents","eval","removeFromGameData","_afterRemoveEntity","ent","lifecycle","triggerHook","systems","graphics","timerId","removeTimer","rbush","deferredEntities","entityDataOrId","updateOptions","warn","getEntityByName","graphicsInterface","updateSize","physics","setBodySize","setPosition","setVelocity","thickness","currentFn","updateConfig","onUpdate","handlers","fn","merged","setRotation","newTexture","prev","updatedEnt","_afterUpdateEntity","removeAllEntities","options","clearCurrentPlayer","excludeByName","Array","isArray","eId","currentPlayerId","part","unload","Entity$1","Entity","static","constructor","nextEntityId","init","Map","bind","getEntities","allEntities","hasEntity","query","match","key","cleanupDestroyedEntities","destroyedComponentData","destroyedType","removeBody","remove","delete","filter","Number","applyLockedProperties","currentVal","subKey","nestedVal","Component","current","i","undefined","isLocked","lockedProps","_entity","EntityClass","hasOwnProperty"],"mappings":"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"}