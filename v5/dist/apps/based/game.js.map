{"version":3,"file":"game.js","sources":["../../../apps/based/game/workerWrapper.js","../../../apps/based/game/GameLoop.js","../../../apps/based/entity/lib/util/ensureColorInt.js","../../../apps/based/entity/lib/layoutEntity.js","../../../apps/based/entity/lib/createEntity.js","../../../apps/based/entity/lib/getEntity.js","../../../apps/based/entity/lib/inflateEntity.js","../../../apps/based/entity/lib/removeEntity.js","../../../apps/based/entity/lib/updateEntity.js","../../../apps/based/entity/lib/removeAllEntities.js","../../../apps/based/entity/EntityClass.js","../../../apps/based/entity/Component.js","../../../apps/based/entity/entity.js","../../../apps/based/game/game.js"],"sourcesContent":["// Dynamically load and return the appropriate Worker class\nasync function getWorkerClass() {\n    if (typeof window === 'undefined') {\n        // Node.js environment\n        const { Worker } = await import('worker_threads');\n        return Worker;\n    } else {\n        // Browser environment\n        return window.Worker;\n    }\n}\n\nexport default getWorkerClass;\n","// import Worker from './workerWrapper.js';\n\nimport getWorkerClass from './workerWrapper.js';\n\nexport default class GameLoop {\n    constructor(config, bp) {\n      // Previous initializations...\n      this.snapshots = [];  // Array to hold snapshots received from the worker\n      this.game = config.game;\n      this.bp = bp;\n\n      this.started = false;\n      this.lastRenderedSnapshotId = null;\n      this.hzMS = config.hzMS || 16.666; // Default to approx 60 FPS if not provided\n      this.accumulator = 0;\n      this.lastGameTick = Date.now();\n      this.lastDelta = 0;\n      this.lastFPS = 0;\n  \n      this.fpsMeasurements = [];\n      this.fpsReportFrequency = config.fpsReportFrequency || 60; // Default to reporting every 60 frames\n      this.frameCount = 0;\n      this.tickCount = 0;\n\n      this.config = config;\n\n      this.init();\n\n    }\n\n    async init() {\n      const Worker = await getWorkerClass();\n\n      this.worker = new Worker(this.config.gameWorker || 'gameWorker.js', { type: 'module' });\n      console.log('fuuudge', this.worker)\n      this.setupWorkerListeners();\n\n    }\n  \n    start() {\n      this.lastGameTick = Date.now();\n      this.loop();\n    }\n\n    stop() {\n      this.game.onlineGameLoopRunning = false;\n    }\n\n    setupWorkerListeners() {\n      this.worker.onmessage = (event) => {\n        const { type, payload } = event.data;\n        switch (type) {\n          case 'updateState':\n            // Store snapshots instead of processing immediately\n            // console.log('Received snapshot from worker:', payload);\n            this.snapshots.push(payload);\n            this.tickCount++;\n            this.bp.emit('game::loop', this.tickCount, payload, {\n              fps: this.lastFPS,\n              frameCount: this.frameCount,\n              lastDelta: this.lastDelta\n            });\n\n            break;\n          default:\n            console.error('Unhandled message type from worker:', type);\n        }\n      };\n    }\n  \n    loop() {\n      if (!this.game.onlineGameLoopRunning) return;\n  \n      let currentTime = Date.now();\n      let deltaTime = (currentTime - this.lastGameTick) / 1000.0;\n      this.lastDelta = deltaTime;\n      this.calculateFPS(deltaTime);\n      this.lastGameTick = currentTime;\n  \n      // Send deltaTime to the worker to process game logic\n      // console.log('postMessage', { type: 'gameTick', payload: { deltaTime } });\n      this.worker.postMessage({ type: 'gameTick', payload: { deltaTime } });\n\n      // Process all pending snapshots\n      while (this.snapshots.length > 0) {\n        let snapshot = this.snapshots.shift(); // Process each snapshot\n        // console.log('Processing snapshot..inflating...', snapshot);\n        // this.inflateSnapshot(this.game, snapshot.entities);\n      }\n\n      this.renderGraphics();\n\n  \n      requestAnimationFrame(this.loop.bind(this));\n    }\n  \n    processWorkerUpdates(data) {\n      // This method can now be refactored or removed if not needed\n    }\n  \n    renderGraphics() {\n      let alpha = this.accumulator / (this.hzMS / 1000.0);\n      this.game.graphics.forEach(graphicsInterface => {\n        // console.log('GameLoop renderGraphics', alpha);\n        // this.graphicsRender(graphicsInterface, this.game, alpha);\n      });\n    }\n\n    calculateFPS(deltaTime) {\n      if (deltaTime > 0) {\n        let currentFPS = 1 / deltaTime;\n        this.fpsMeasurements.push(currentFPS);\n  \n        if (this.fpsMeasurements.length > this.fpsReportFrequency) {\n          this.fpsMeasurements.shift();\n        }\n  \n        this.frameCount++;\n        if (this.frameCount % this.fpsReportFrequency === 0) {\n          let sumFPS = this.fpsMeasurements.reduce((a, b) => a + b, 0);\n          let averageFPS = sumFPS / this.fpsMeasurements.length;\n          this.lastFPS = averageFPS;\n          // this.game.emit('fps', averageFPS);\n          this.fpsMeasurements = [];\n        }\n      }\n    }\n}\n","export default function ensureColorInt(color) {\n\n  if (!color) {\n    return color;\n  }\n\n  // Mapping of common color names to hex values\n  const colorNameToHex = {\n    red: '#FF0000',\n    green: '#00FF00',\n    blue: '#0000FF',\n    black: '#000000',\n    white: '#FFFFFF',\n    yellow: '#FFFF00',\n    purple: '#800080',\n    orange: '#FFA500',\n    pink: '#FFC0CB',\n    indigo: '#4B0082',\n    violet: '#EE82EE',\n    // Add more common colors as needed\n  };\n\n  // If color is already a number, return it as is\n  if (typeof color === 'number') {\n    return color;\n  }\n\n  // If color is a hex string (with #), convert it to an integer\n  if (typeof color === 'string' && color.startsWith('#')) {\n    return parseInt(color.replace('#', ''), 16);\n  }\n\n  // If color is a common color name, convert it using the mapping\n  if (typeof color === 'string' && colorNameToHex[color.toLowerCase()]) {\n    return parseInt(colorNameToHex[color.toLowerCase()].replace('#', ''), 16);\n  }\n\n  // If color format is unrecognized, throw an error or return a default color\n  console.error('Unrecognized color format:', color);\n  return parseInt('000000', 16); // Default to black\n}","// TODO: needs to be able to attach by container/entity id or name, not just by name\nexport default function layoutEntity(container, entityId) {\n\n  let containerEnt = this.game.findEntity(container); // Adjust this line to match how you access the boss entity\n\n  if (!containerEnt) {\n    throw new Error('Container not found: ' + container);\n  }\n  let containerPosition = containerEnt.position || { x: 0, y: 0, z: 0 };\n  // console.log('found container ent to work with', containerEnt);\n\n  let layoutType = 'none'; // 'none', 'grid', 'flex', 'stack', 'custom-function'\n  let origin = 'center'; // 'center', 'bottom-right', 'top-right', 'bottom-left', 'center-left', 'center-right', 'top-center', 'bottom-center', 'top-left'\n\n  // Legacy API, don't pollute style scope with new / unknown  properties\n  if (containerEnt.style && containerEnt.style.layout) {\n    layoutType = containerEnt.style.layout;\n  }\n  if (containerEnt.style && containerEnt.style.origin) {\n    origin = containerEnt.style.origin;\n  }\n\n  // New API\n  if (containerEnt.meta && containerEnt.meta.layout) {\n    layoutType = containerEnt.meta.layout;\n  }\n\n  //\n  // Add the current new entity id to the container items\n  //\n  if (!containerEnt.items) {\n    containerEnt.items = [];\n  }\n  containerEnt.items.push(entityId); // Remark: We are not saving the associations here?\n\n  // TODO: add better support for 1:1 flex mapping\n  if (layoutType === 'flex') {\n    const flexConfig = containerEnt.meta.flex || containerEnt.style.flex; // Assuming flex config is stored here\n    const items = containerEnt.items.map(itemId => this.game.getEntity(itemId));\n    applyFlexLayout.call(this, containerEnt, items, flexConfig);\n  } else if (layoutType === 'grid') {\n    const gridConfig = containerEnt.meta.grid || containerEnt.style.grid; // Assuming grid config is stored here\n    const items = containerEnt.items.map(itemId => this.game.getEntity(itemId));\n    applyGridLayout.call(this, containerEnt, items, gridConfig);\n  }\n\n  //\n  // Default / no layout indicates relative position from top left origin ( -1, -1 )\n  // Remark: May want to add custom origins such as center ( 0, 0 ) or bottom right ( 1, 1 ), etc\n  //\n  if (layoutType === 'none') {\n    // Retrieve the entity to be positioned\n    let entity = this.game.getEntity(entityId);\n\n    // Check if entity exists\n    if (!entity) {\n      console.error('Entity not found: ' + entityId);\n      return;\n    }\n\n    // When the origin should be centered, calculate offsets to position the entity's center at the container's center\n    let offsetX = entity.position.x; // Centered horizontally\n    let offsetY = entity.position.y; // Centered vertically\n    // If the origin is explicitly set to 'top-left', adjust offsets to position the top-left corner of the entity at the container's center\n    // TODO: fix this and move to separate file / sub-system for layout / flex styles / etc\n    if (origin === 'top-left') {\n      offsetX = -entity.size.width / 2;\n      offsetY = -entity.size.height / 2;\n    } else {\n      // For a centered origin, adjust so the entity's center aligns with the container's center\n      offsetX -= entity.size.width / 2;\n      offsetY -= entity.size.height / 2;\n    }\n\n    // Calculate the cumulative position of the container to account for nesting\n    // TODO: traverse up the container hierarchy to get the cumulative position\n    // let cumulativeContainerPosition = getCumulativePosition(containerEnt);\n    let cumulativeContainerPosition = containerEnt.position;\n    \n    // Calculate the entity's new position relative to the cumulative container position\n    let newPosition = {\n      x: cumulativeContainerPosition.x + (origin === 'top-left' ? -entity.size.width / 2 : -entity.size.width / 2),\n      y: cumulativeContainerPosition.y + (origin === 'top-left' ? -entity.size.height / 2 : -entity.size.height / 2),\n      z: containerPosition.z // Assuming z-index remains constant or is managed elsewhere\n    };\n\n\n    newPosition.x = containerPosition.x + offsetX;\n    newPosition.y = containerPosition.y + offsetY;\n\n    // Update the entity's position\n    this.game.updateEntity({ id: entityId, position: newPosition });\n\n    // Log for debugging purposes\n    // console.log(`Entity ${entityId} positioned at (${newPosition.x}, ${newPosition.y}, ${newPosition.z}) relative to container`);\n  }\n\n\n  //\n  // Layout container items using grid layout algorithm\n  //\n\n  if (layoutType === 'grid') {\n\n    let cols = containerEnt.meta.grid.columns || 1;\n    let rows = containerEnt.meta.grid.rows || 1;\n\n    if (containerEnt.style && containerEnt.style.grid) {\n      cols = containerEnt.style.grid.columns || cols;\n      rows = containerEnt.style.grid.rows || rows;\n    }\n\n    if (typeof cols !== 'number' || typeof rows !== 'number') {\n      console.log('containerEnt.layout', containerEnt.layout);\n      throw new Error('Grid layout requires cols and rows to be numbers');\n    }\n\n    //console.log(\"ahhhhhhhhhh\", cols, rows)\n    // get all the other items in the container\n    let containerItems = containerEnt.items || [];\n\n    // call game.getEntity() for each item to get its size and position\n    // Remark: use components api to only fetch the necessary components ( instead of entire ent )\n    containerItems = containerItems.map((itemId) => {\n      return this.game.getEntity(itemId);\n    });\n\n    let containerSize = containerEnt.size;\n\n    // Calculate the width and height for each grid cell\n    let cellWidth = containerSize.width / cols;\n    let cellHeight = containerSize.height / rows;\n    //alert(containerSize.width)\n    //alert(containerSize.height)\n\n    // Loop through each item in the container\n    containerItems.forEach((item, index) => {\n      // Calculate the row and column for the current item based on its index\n      let row = Math.floor(index / cols);\n      let col = index % cols;\n\n      // skip if item is not found\n      if (!item) {\n        // Remark: This should *not* happen, investigate why index is null value\n        console.log('warning: item not found in container', index, item)\n        return;\n      }\n\n      let paddingTop = 0;\n      let paddingLeft = 0;\n      // Set the starting position to the top-left corner of the container's bounding box\n      let positionX = containerPosition.x - containerSize.width / 2 + paddingLeft;\n      let positionY = containerPosition.y - containerSize.height / 2 + paddingTop;\n      let positionZ = containerPosition.z;\n\n      // Calculate the position for the current item, aligning the center of the entity with the center of the grid cell\n      let itemPosition = {\n        x: positionX + (col * cellWidth) + (cellWidth / 2), // Center of the grid cell\n        y: positionY + (row * cellHeight) + (cellHeight / 2), // Center of the grid cell\n        z: item.position.z // Assuming z-index remains constant or is managed elsewhere\n      };\n\n      // Update the entity's position using the game framework's method\n      this.game.updateEntity({ id: item.id, position: itemPosition }, {\n        skipAfterUpdateEntity: true\n      });\n\n      // console.log(`Item ${item.id} positioned at row ${row}, column ${col}`);\n    });\n\n    // console.log('adding item to container using grid layout algorithm');\n  }\n\n  //\n  // Layout container items using stack layout algorithm\n  //\n  if (layoutType === 'stack') {\n    // Define stack offset values\n    let stackOffsetX = 0; // Horizontal offset for each stacked item\n    let stackOffsetY = 5; // Vertical offset for each stacked item\n\n\n    // Retrieve the entity to be positioned\n    let entity = this.game.getEntity(entityId);\n\n    // Check if entity exists\n    if (!entity) {\n      console.error('Entity not found: ' + entityId);\n      return;\n    }\n\n    // TODO: we could add multiple ways to stack here by cardinal direction or custom function\n    // default stack top to bottom using entity size\n    stackOffsetY = entity.size.height + 5;\n\n\n    // Determine the stack position based on the number of items already in the container\n    let stackIndex = containerEnt.items.length - 1; // -1 because we've already added the new entityId to containerEnt.items\n\n    // Calculate the entity's new position based on stack index and offsets\n    let newPosition = {\n      x: containerPosition.x + stackIndex * stackOffsetX,\n      y: containerPosition.y + stackIndex * stackOffsetY,\n      z: containerPosition.z // Assuming z-index remains constant or is managed elsewhere\n    };\n\n    // Update the entity's position\n    this.game.updateEntity({ id: entityId, position: newPosition });\n\n    // Log for debugging purposes\n    console.log(`Entity ${entityId} stacked at index ${stackIndex} with position (${newPosition.x}, ${newPosition.y}, ${newPosition.z}) relative to container`);\n  }\n\n  //\n  // Layout container items using custom function\n  //\n  if (typeof layoutType === 'function') {\n    console.log('adding item to container using custom layout algorithm');\n    throw new Error('Custom layout algorithm functions are yet implemented!')\n  }\n\n}\n\nfunction applyFlexLayout(container, items, layoutConfig) {\n  const { flexDirection = 'row', justifyContent = 'flex-start', alignItems = 'center' } = layoutConfig;\n  const isRow = flexDirection.includes('row');\n  const mainSize = isRow ? 'width' : 'height';\n  const crossSize = isRow ? 'height' : 'width';\n  const mainStart = isRow ? 'x' : 'y';\n  const crossStart = isRow ? 'y' : 'x';\n\n  let mainAxisCurrentPosition = 0;\n  let crossAxisPosition = 0; // This can be adjusted for alignItems other than 'center'\n\n  for (const item of items) {\n    // Position each item along the main axis\n    item.position[mainStart] = mainAxisCurrentPosition;\n    // Adjust main axis position for the next item\n    mainAxisCurrentPosition += item.size[mainSize];\n\n    // Align items along the cross axis\n    switch (alignItems) {\n      case 'flex-start':\n        item.position[crossStart] = 0;\n        break;\n      case 'flex-end':\n        item.position[crossStart] = container.size[crossSize] - item.size[crossSize];\n        break;\n      case 'center':\n      default:\n        item.position[crossStart] = (container.size[crossSize] - item.size[crossSize]) / 2;\n        break;\n    }\n\n    // Update the entity's position in the game\n    this.game.updateEntity({ id: item.id, position: item.position });\n  }\n}\n\nfunction applyGridLayout(container, items, layoutConfig) {\n  const { gridTemplateColumns = '1fr', gridTemplateRows = '1fr' } = layoutConfig;\n  const cols = gridTemplateColumns.split(' ').length; // Simplified assumption\n  const rows = Math.ceil(items.length / cols);\n\n  const cellWidth = container.size.width / cols;\n  const cellHeight = container.size.height / rows;\n\n  items.forEach((item, index) => {\n    const col = index % cols;\n    const row = Math.floor(index / cols);\n\n    item.position.x = col * cellWidth;\n    item.position.y = row * cellHeight;\n\n    // Update the entity's position in the game\n    this.game.updateEntity({ id: item.id, position: item.position });\n  });\n}\n\n\n// Function to calculate the cumulative position of a container\nfunction getCumulativePosition(container) {\n  let position = { x: container.position.x, y: container.position.y, z: container.position.z };\n\n  if (!container.container) {\n    return position;\n  }\n  let parentContainer = game.getEntityByName(container.container); // Assuming there's a way to access the parent container\n\n  if (parentContainer) {\n    position.x += parentContainer.position.x;\n    position.y += parentContainer.position.y;\n    // Assuming z-index remains constant or is managed elsewhere, so not accumulating z\n    parentContainer = parentContainer.parent; // Move up to the next parent container\n  }\n\n  return position;\n}\n","// TODO: add support for Entity.items\n\nimport EntityClass from '../EntityClass.js'\n// TODO: remove TimersComponent import, use game reference instead ( reduce imported code )\n//import TimersComponent from '../../../Component/TimersComponent.js';\nimport ensureColorInt from './util/ensureColorInt.js';\nimport layoutEntity from './layoutEntity.js';\n\n\n\n\nfunction distanceSquared(x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  return dx * dx + dy * dy;\n}\n\nfunction deferEntityCreation(entityData) {\n  // Add entity data to a spatial data structure\n  spatialStructure.add(entityData);\n}\n\n// ignoreSetup set to true will ignore the setup phase of createEntity\n// the setup phase assigns default values to the entity and auto-id\n// this is currently being used from `rbush` plugin when creating deferred entities\nexport default function createEntity(config = {}, ignoreSetup = false) {\n  // console.log('createEntity', config)\n\n  let entityId;\n\n  // Remark: See: ./Game/Lifecyle.js for Mantra Lifecycle Hooks\n  // config = this.bp.lifecycle.triggerHook('before.createEntity', config);\n\n  if (!ignoreSetup) {\n    entityId = this._generateId();\n\n    let defaultConfig = {\n      id: entityId,\n      name: null,\n      kind: null,\n      body: true,\n      shape: 'triangle',\n      color: null,\n      position: { x: 0, y: 0, z: 0 },\n      startingPosition: null,\n      velocity: { x: 0, y: 0, z: 0 },\n      rotation: 0,\n      mass: 100,\n      density: 100,\n      health: Infinity,\n      score: 0,\n      // radius: null,\n      height: 16,\n      width: 16,\n      depth: 16,\n      // Remark: height, width, and depth are being replaced by size\n      size: { width: 100, height: 100, depth: 16 },\n      lifetime: null,\n      maxSpeed: 100,\n      isStatic: false,\n      isSensor: false,\n      restitution: 0,\n      container: null,\n      items: null,\n      sutra: null,\n      scene: [],\n      meta: null,\n      collectable: false,\n      hasInventory: true,\n      owner: 0, // 0 = server\n      source: null, // originating source of the entity, in most cases this is process id\n      inputs: null,\n      value: null,\n      destroyed: false,\n      type: 'NONE',\n      friction: 0.1,  // Default friction\n      frictionAir: 0.01, // Default air friction\n      frictionStatic: 0.5, // Default static friction\n      lockedProperties: null, // object hash of properties that should never be updated\n      actionRateLimiter: null, // object hash of state history\n      timers: null, // object hash timers for TimersComponent.js\n      yCraft: null, // object hash of properties for YCraft.js\n      text: null,\n      style: null,\n      texture: null,\n\n      collisionStart: true,\n      collisionActive: false,\n      collisionEnd: false,\n\n      pointerdown: false,\n      pointerup: false,\n      pointermove: false,\n      pointerover: false,\n      pointerout: false,\n      pointerenter: false,\n      pointerleave: false,\n\n      onDrop: null,\n      afterItemCollected: null,\n\n      afterRemoveEntity: null,\n      afterCreateEntity: null,\n      afterUpdate: null,\n      update: null,\n      exit: null,\n      ctick: this.bp.tick,\n      utick: this.bp.tick\n    };\n\n    // Remark: Adding support for new Entity.size prop, removing Entity.height and Entity.width\n    if (typeof config.size === 'object') {\n      config.width = config.size.width;\n      config.height = config.size.height;\n      config.depth = config.size.depth;\n    } else {\n      // Remark: Added 2/8/2024 Backwards support for legacy API, removed soon\n      config.size = { width: config.width, height: config.height, depth: config.depth };\n    }\n\n    // merge config with defaultConfig\n    config = { ...defaultConfig, ...config };\n\n    // before mutating any game state based on the incoming entity, we *must* check that certain properties validate\n    // check that position is well formed, contains, x,y,z, and is all valid numbers\n    if (config.position &&\n      (typeof config.position.x !== 'number' || isNaN(config.position.x) ||\n        typeof config.position.y !== 'number' || isNaN(config.position.y))) {\n      console.log('Entity.createEntity could not create with data', config);\n      throw new Error('Invalid position for entity');\n    }\n\n    /*\n    if (this.bp.systems.rbush) {\n      this.bp.systems.rbush.addEntity(config);\n    }\n    */\n\n    // Remark: Always add to deferredEntities, this is now being used to store all local\n    //         game data that may not yet be in the game.data scope ( off screen / not loaded )\n         // this.bp.deferredEntities[config.id.toString()] = config;\n    // TODO: add option for allowSpatialTreeToDefer to be set to false ( ignore FoV for certain ents )\n    \n    /*\n    if (this.bp.config.useFoV) {\n      // check to see if entity is within game.data.fieldOfView,\n      // if not, we will defer creation until it is\n      let currentPlayer = this.bp.getCurrentPlayer();\n      if (currentPlayer) {\n        let incomingPosition = config.position || { x: 0, y: 0, z: 0 };\n        let distance = distanceSquared(currentPlayer.position.x, currentPlayer.position.y, incomingPosition.x, incomingPosition.y);\n        let fieldOfViewSquared = this.bp.data.fieldOfView * this.bp.data.fieldOfView;\n        if (distance > fieldOfViewSquared) {\n          return;\n        }\n      }\n\n    }\n      */\n\n  }\n\n  entityId = config.id;\n  const entity = new EntityClass(entityId);\n\n  /*\n  entity.getTimer = (timerId) => {\n    return this.bp.components.timers.get(entityId, timerId);\n  };\n  */\n\n  if (!config.startingPosition) {\n    config.startingPosition = config.position;\n  }\n\n  const { name, type, kind, position, rotation, startingPosition, body, mass, density, velocity, isSensor, isStatic, lockedProperties, width, height, depth, size, radius, shape, color, maxSpeed, health, score, items, container, sutra, scene, meta, collectable, hasInventory, owner, source, inputs, value, lifetime, yCraft, text, style, texture, collisionActive, collisionStart, collisionEnd, pointerdown, pointerup, pointermove, pointerenter, pointerleave, pointerover, pointerout, onDrop, afterRemoveEntity, afterCreateEntity, afterUpdateEntity, afterItemCollected, update, exit, ctick, utick } = config;\n\n  let { x, y } = position;\n\n  /*\n  if (typeof config.position !== 'undefined') {\n    position.x = config.position.x;\n    position.y = config.position.y;\n  }\n  */\n\n  // asset that color is integer value\n  if (typeof color === 'string') {\n    // check to see if # is present, if so, convert hex to int\n    // needs to map common colors to integer values, red, green, black , etc\n  }\n\n  let ensuredColor = ensureColorInt(color);\n  \n  // console.log('position', position, 'width', width, 'height', height)\n  // Using game's API to add components\n  this.bp.addComponent(entityId, 'type', type || 'PLAYER');\n  this.bp.addComponent(entityId, 'name', name || null);\n  this.bp.addComponent(entityId, 'kind', kind);\n  this.bp.addComponent(entityId, 'position', position);\n  this.bp.addComponent(entityId, 'startingPosition', startingPosition);\n  this.bp.addComponent(entityId, 'velocity', velocity);\n  this.bp.addComponent(entityId, 'rotation', rotation);\n  this.bp.addComponent(entityId, 'mass', mass);\n  this.bp.addComponent(entityId, 'density', density);\n  this.bp.addComponent(entityId, 'health', health);\n  this.bp.addComponent(entityId, 'score', score);\n  this.bp.addComponent(entityId, 'width', width);\n  this.bp.addComponent(entityId, 'height', height);\n  this.bp.addComponent(entityId, 'depth', depth);\n  // Remark: height, width, and depth are being replaced by size\n  this.bp.addComponent(entityId, 'size', size);\n  this.bp.addComponent(entityId, 'radius', radius);\n  this.bp.addComponent(entityId, 'shape', shape);\n  this.bp.addComponent(entityId, 'color', ensuredColor);\n  this.bp.addComponent(entityId, 'maxSpeed', maxSpeed);\n  this.bp.addComponent(entityId, 'owner', owner);\n  // source is reversed in order to form the relationship between the source and the entity\n  this.bp.addComponent(source, 'source', source + '_' + entityId);\n  this.bp.addComponent(entityId, 'items', items);\n  this.bp.addComponent(entityId, 'scene', scene);\n\n  this.bp.addComponent(entityId, 'meta', meta);\n  this.bp.addComponent(entityId, 'collectable', collectable);\n  \n  // if entity is allowed to pickup items, add an inventory component\n  this.bp.addComponent(entityId, 'hasInventory', hasInventory);\n\n  this.bp.addComponent(entityId, 'value', value);\n\n  this.bp.addComponent(entityId, 'inputs', inputs);\n  this.bp.addComponent(entityId, 'lifetime', lifetime);\n  this.bp.addComponent(entityId, 'destroyed', false);\n  this.bp.addComponent(entityId, 'creationTime', Date.now());  // Current time in milliseconds\n  this.bp.addComponent(entityId, 'isSensor', isSensor);\n  this.bp.addComponent(entityId, 'isStatic', isStatic);\n  this.bp.addComponent(entityId, 'lockedProperties', lockedProperties);\n  this.bp.addComponent(entityId, 'actionRateLimiter', {});\n  // TODO: clean up API contract with Component\n      // this.bp.addComponent(entityId, 'timers', new TimersComponent('timers', entityId, this.bp));\n  this.bp.addComponent(entityId, 'yCraft', yCraft);\n  this.bp.addComponent(entityId, 'text', text);\n  this.bp.addComponent(entityId, 'style', style);\n  this.bp.addComponent(entityId, 'texture', texture);\n\n\n  this.bp.addComponent(entityId, 'afterItemCollected', afterItemCollected);\n\n\n  this.bp.addComponent(entityId, 'afterRemoveEntity', afterRemoveEntity);\n  this.bp.addComponent(entityId, 'afterCreateEntity', afterRemoveEntity);\n  this.bp.addComponent(entityId, 'afterUpdateEntity', afterUpdateEntity);\n\n\n  this.bp.addComponent(entityId, 'collisionActive', collisionActive);\n  this.bp.addComponent(entityId, 'collisionStart', collisionStart);\n  this.bp.addComponent(entityId, 'collisionEnd', collisionEnd);\n\n  this.bp.addComponent(entityId, 'pointerdown', pointerdown);\n  this.bp.addComponent(entityId, 'pointerup', pointerup);\n  this.bp.addComponent(entityId, 'pointermove', pointermove);\n  this.bp.addComponent(entityId, 'pointerenter', pointerenter);\n  this.bp.addComponent(entityId, 'pointerleave', pointerleave);\n  this.bp.addComponent(entityId, 'pointerover', pointerover);\n  this.bp.addComponent(entityId, 'pointerout', pointerout);\n\n  // Drag and Drop Events\n  this.bp.addComponent(entityId, 'onDrop', onDrop);\n\n  this.bp.addComponent(entityId, 'update', update);\n  this.bp.addComponent(entityId, 'exit', exit);\n  this.bp.addComponent(entityId, 'ctick', ctick);\n  this.bp.addComponent(entityId, 'utick', utick);\n\n  let _sutra;\n  // if the incoming sutra is an object, it is config object which needs to be scoped to the new entity\n  if (typeof sutra === 'object' && sutra !== null) {\n    if (typeof sutra.rules === 'function') {\n      if (typeof sutra.config !== 'object') {\n        sutra.config = {};\n      }\n      // if there is a valid rules function, we will create the Sutra instance\n      // it is assumed the signature of the rules function is (game, entityId, config)\n      // this may change in the future\n      _sutra = sutra.rules(this.bp, entityId, sutra.config);\n    } else {\n      // could be a Sutra instance object instance without config object\n      _sutra = sutra;\n    }\n  } else {\n    // the incoming sutra was not a non-null object\n    // it could be null or a function, assign component value without modification\n    _sutra = sutra;\n  }\n\n  this.bp.addComponent(entityId, 'sutra', _sutra);\n\n  if (body) {\n    // remove this step, have everything work in addToWorld\n    let body = {\n      entityId: entityId,\n      width: width,\n      height: height,\n      radius: radius,\n      type: type,\n      shape: shape,\n      position: position,\n      velocity: velocity,\n      rotation: rotation,\n      mass: mass,\n      density: density,\n      isStatic: isStatic,\n      isSensor: isSensor,\n      restitution: config.restitution,\n      friction: config.friction,\n      frictionAir: config.frictionAir,\n      frictionStatic: config.frictionStatic\n    }\n    body.myEntityId = entityId; // TODO myEntityId is legacy, remove\n\n    /* Disabled physics for now\n    this.bp.physics.addToWorld(body);\n    // TODO: bodyMap needs to be removed\n    //       in order to decouple physics from game, we'll need to use body references in app space\n    //       and allow the physics interface to use entity.id as the key between worker and app space\n    // this.bp.bodyMap[entityId] = body;\n\n    if (velocity && (velocity.x !== 0 || velocity.y !== 0)) {\n      this.bp.physics.setVelocity(entityId, velocity);\n    }\n\n    if (position) {\n      this.bp.physics.setPosition(entityId, position);\n    }\n    if (typeof rotation !== 'undefined') {\n      if (this.bp.physics && this.bp.physics.setRotation) {\n        this.bp.physics.setRotation(entityId, rotation);\n      }\n    }\n      */\n  } else {\n    // immediately add to changedEntities\n    // this.bp.changedEntities.add(entityId);\n  }\n\n  // Add the entity to the game entities scope\n  // TODO: new Entity() should do this\n  // console.log('setting id', entityId, 'to entity')\n  this.bp.entities.set(entityId, {\n    id: entityId\n  });\n  // console.log(\"SETTING CHANGED\", entityId)\n  // this.bp.changedEntities.add(entityId);\n\n  // get updated entity with components\n  let updatedEntity = this.bp.getEntity(entityId);\n\n  if (typeof updatedEntity.pendingRender === 'undefined') {\n    updatedEntity.pendingRender = {};\n  }\n  \n  /*\n  this.bp.graphics.forEach(function (graphicsInterface) {\n    updatedEntity.pendingRender[graphicsInterface.id] = true;\n  });\n  */\n\n  // updates entity in the ECS entity Map scope\n  this.bp.entities.set(entityId, updatedEntity);\n\n  // TODO: move this to separate file\n  if (container) {\n    this.layoutEntity(container, entityId);\n  }\n\n  // updates entity in the flat game.data scope\n  this.bp.data.ents = this.bp.data.ents || {};\n  this.bp.data.ents._ = this.bp.data.ents._ || {};\n  this.bp.data.ents._[entityId] = updatedEntity;\n  this.bp.data.ents[updatedEntity.type] = this.bp.data.ents[updatedEntity.type] || [];\n  this.bp.data.ents[updatedEntity.type].push(updatedEntity);\n\n  // check to see if there are no active players, if so set the entity as the current player\n  // TODO: config flag\n  if (updatedEntity.type === 'PLAYER' && this.bp.data.ents.PLAYER) {\n    let activePlayerCount = Object.keys(this.bp.data.ents.PLAYER).length;\n    // console.log(\"activePlayerCount\", activePlayerCount)\n    if (activePlayerCount < 1) {\n      // console.log('Setting player id', entityId);\n      this.bp.setPlayerId(entityId);\n    }\n  }\n\n  //\n  // Entity Lifecycle afterCreateEntity\n  //\n  let _afterCreateEntity;\n  if (typeof config.afterCreateEntity === 'function') {\n    _afterCreateEntity = config.afterCreateEntity;\n  }\n  if (_afterCreateEntity) {\n    _afterCreateEntity(config);\n  }\n\n  //\n  //\n  // Game Lifecycle after.createEntity\n  // updatedEntity = this.bp.lifecycle.triggerHook('after.createEntity', config);\n\n  return updatedEntity;\n}","export default function getEntity(entityId) {\n    \n  if (typeof entityId === 'string') {\n    entityId = parseInt(entityId); // for now, this can be removed when we switch Component.js to use Maps\n  }\n\n  if (!this.bp.entities.has(entityId)) {\n    return null;\n  }\n\n  const entity = {};\n\n  // Iterate over all registered components and fetch their data if available\n  for (const componentType in this.bp.components) {\n    let componentData = this.bp.getComponent(entityId, componentType);\n    if (typeof componentData !== 'undefined' && componentData !== null) {\n      entity[componentType] = componentData;\n    }\n  }\n\n  if (Object.keys(entity).length === 0) {\n    return null;\n  }\n\n  entity.id = entityId;\n\n  return entity;\n\n}","export default function inflateEntity(entityData) {\n  let game = this.game;\n\n  // Check for entity marked for destruction and remove immediately if so\n  if (entityData.destroyed === true) {\n    game.removeGraphic(entityData.id);\n    game.removeEntity(entityData.id);\n    return;\n  }\n\n  // Check for entities marked for local removal, skip updates if found\n  if (game.removedEntities.has(entityData.id)) {\n    console.log('Skipping update for locally removed entity:', entityData.id);\n    return;\n  }\n\n  // Check if the entity is from a remote source and handle potential source conflicts\n  if (entityData.source != null) {\n    // This entity orginated from a remote source, we'll need to account for an entity.id that was\n    // created in another system\n    let existingSourceId = game.components.source.get(entityData.source + '-' + entityData.id); // get concat source-id\n    // If a prior source exists, we should perform an update using the sourceId\n    // If the entity exists and has a different source, log the conflict and decide on handling strategy\n    if (existingSourceId) { // sourceId?\n      // console.log(`Entity ${entityData.id} from source ${entityData.source} encountered, previously associated with source ${existingSource}. Handling potential ID conflict.`);\n      // Implement conflict resolution strategy here, e.g., update, replace, ignore, etc.\n      entityData.id = entityData.source.split('_')[1]; // Remark brittle, maybe sourceId\n      // console.log(\"ALREADY EXISTS updateOrCreate REMOTE\", entityData);\n      return updateOrCreate(game, entityData);\n    } else {\n      delete entityData.id;\n      // store a new source refer\n\n      // since this ent is remote, we should attempt to build it by type,\n      // in order to re-establish the correct components and behaviors\n      let type = entityData.type;\n      if (type) {\n\n        // tolowercase then uppercase first letter\n        type = type.toLowerCase();\n        type = type.charAt(0).toUpperCase() + type.slice(1);\n\n        try {\n          let defaultTypeConfig = this.game.make();\n          defaultTypeConfig[type](entityData);\n          let config = defaultTypeConfig.build();\n          // merge the default type config with the entity data\n          for (let p in config) {\n            entityData[p] = config[p];\n          }\n          // remove any undefined values or null values\n          for (let p in entityData) {\n            if (typeof entityData[p] === 'undefined' || entityData[p] === null) {\n              delete entityData[p];\n            }\n          }\n        }\n        catch (err) {\n          // This will happen for any type that is not defined by an active plugin\n          // console.warn('Failed to build remote entity by type:', type, err, 'using default build');\n          defaultBuild(game, entityData);\n        }\n\n        // console.log('proceeding with typed data', entityData)\n\n      } else {\n        defaultBuild(game, entityData);\n      }\n      // console.log('built ent with data', entityData)\n      return updateOrCreate(game, entityData);\n    }\n  } else {\n    return updateOrCreate(game, entityData);\n  }\n\n}\n\nfunction defaultBuild(game, entityData) {\n  // console.log('defaultBuild', entityData.type)\n  // merge default build make \n  let defaultConfig = game.make().build();\n  for (let p in defaultConfig) {\n    if (typeof entityData[p] === 'undefined' || entityData[p] === null) {\n      entityData[p] = defaultConfig[p];\n    }\n  }\n  // remove any undefined values or null values ( should not be necessary at this stage ) ( more tests )\n  // console.log('inflateENtity defaultBuild got data', entityData)\n\n  // Why though???? This could be a real problem with peer to peer data\n  // There would technically be no way of stopping while(true) alert('hello') from being sent\n  // Better to not allow custom events to be sent / inflated\n  // This means that only pre-defined shared objects can be sent\n  // Such that the events are known and can be handled / cannot be custom\n  let supportedSerializedEvents = ['collisionStart']; // TODO: add all events with tests\n\n  for (let p in entityData) {\n\n    if (supportedSerializedEvents.includes(p)) {\n      // this is a serialized function, create a new function from the string and assign it to the entity\n      // console.log('inflateEntity serialized function', entityData.type, entityData[p], entityData);\n      // this is a function that had .toSTring() called on it, we need to re-create the function\n      try {\n        // Remark: This try/catch is not gaurenteed to catch all eval() errors\n        entityData[p] = eval('(' + entityData[p] + ')');\n      } catch (err) {\n        console.log('Failed to inflate serialized function', entityData.type, entityData[p], entityData, err)\n      }\n      //console.log(\"after inflateENtity seralize fn\", entityData[p])\n    }\n\n    if (typeof entityData[p] === 'undefined' || entityData[p] === null) {\n      delete entityData[p];\n    }\n  }\n}\n\nfunction updateOrCreate(game, entityData) {\n  // After handling potential source conflicts, proceed to create or update the entity\n  let localEntity = game.entities.get(entityData.id);\n  if (!localEntity) {\n    // If it's a new entity or a remote entity not seen before, create it\n    //console.log(\"createEntity LOCAL\", entityData);\n    return game.createEntity(entityData);\n  } else {\n    //console.log(\"updateEntity LOCAL\", entityData);\n    // If it's an existing entity, update it\n    return game.updateEntity(entityData);\n  }\n\n}","// TODO: double check that all components values are being cleared on removal of ent\nexport default function removeEntity(entityId, removeFromGameData = true) {\n\n  let ent = this.game.entities.get(entityId);\n\n  if (!ent) {\n    return;\n  }\n\n  let _afterRemoveEntity;\n\n  if (typeof ent.afterRemoveEntity === 'function') {\n    _afterRemoveEntity = ent.afterRemoveEntity;\n  }\n\n  let canBeRemoved = this.game.lifecycle.triggerHook('before.removeEntity', ent);\n\n  if (canBeRemoved === false) {\n    return;\n  }\n\n  if (ent && this.game.systems.graphics && ent.graphics) {\n    // Is this best done here? or in the graphics plugin?\n    this.game.systems.graphics.removeGraphic(entityId);\n  }\n  if (ent) {\n    this.game.components.destroyed.set(entityId, true);\n\n    // check to see if any timers exist, if so clear them all\n    if (this.game.components.timers.get(entityId)) {\n      let timers = this.game.components.timers.get(entityId);\n      for (let timerId in timers.timers) {\n        timers.removeTimer(timerId);\n      }\n    }\n\n    // update the entity with the destroyed state\n    let updatedEntity = this.game.getEntity(entityId);\n    this.game.entities.set(entityId, updatedEntity);\n\n    if (updatedEntity) {\n      // actually remove the entity from the game world\n      // will be set to false for field of view related removals\n      if (removeFromGameData) {\n        if (this.game.systems.rbush) {\n          this.game.systems.rbush.removeEntity(updatedEntity);\n        }\n        delete this.game.deferredEntities[entityId];\n      }\n    }\n\n  }\n\n  if (_afterRemoveEntity) {\n    _afterRemoveEntity(ent);\n  }\n  this.game.lifecycle.triggerHook('after.removeEntity', ent);\n\n}","import ensureColorInt from './util/ensureColorInt.js';\n\nexport default function updateEntity(entityDataOrId, entityData, updateOptions = {}) {\n\n  if (typeof entityDataOrId === 'string' || typeof entityDataOrId === 'number') {\n    entityData = { id: entityDataOrId, ...entityData };\n  } else {\n    entityData = entityDataOrId;\n  }\n\n  // Remark: See: ./Game/Lifecyle.js for Mantra Lifecycle Hooks\n  entityData = this.game.lifecycle.triggerHook('before.updateEntity', entityData);\n\n  if (entityData == null) {\n    console.warn('updateEntity was not provided a valid entityData', entityData);\n    console.warn('This is most likely the result of passing invalid data to updateEntity()');\n    return;\n  }\n\n  // console.log('updateEntity', entityData)\n  let entityId = entityData.id;\n  if (typeof entityId === 'undefined') {\n    // check to see if we have a name, if so, find the entity by name\n    if (entityData.name) {\n      let ent = this.game.getEntityByName(entityData.name);\n      if (ent) {\n        entityId = ent.id;\n      }\n    }\n  }\n\n  if (typeof entityId === 'undefined') {\n    console.log('Error: updateEntity was not provided a valid entity.id or entity.name', entityData);\n    console.log('This is most likely the result of passing invalid data to updateEntity()');\n    return;\n  }\n\n  let ent = this.game.getEntity(entityId);\n\n  // if the state doesn't exist, return error\n  if (!ent) {\n    //console.log('Error: updateEntity called for non-existent entity', entityId, entityData);\n    //console.log('This should not happen, if a new state came in it should be created');\n    return;\n  }\n\n  // Remove destroyed entities\n  if (entityData.destroyed) {\n    this.removeEntity(entityId);\n    return;\n  }\n\n  // not a component property yet, just ad-hoc on client\n  ent.pendingRender = {};\n  this.game.graphics.forEach(function (graphicsInterface) {\n    ent.pendingRender[graphicsInterface.id] = true;\n  });\n\n  if (entityData.color) {\n    // entityData.color may be color name as string, hex code, or integer value\n    // ensureColorInt will convert incoming color to safe integer value\n    //console.log('entityData.color', entityData.color)\n    let ensuredColor = ensureColorInt(entityData.color);\n    // console.log('ensuredColor', ensuredColor)\n    this.game.components.color.set(entityId, ensuredColor);\n  }\n\n  let updateSize = false;\n  if (entityData.height) {\n    updateSize = true;\n    this.game.components.height.set(entityId, entityData.height);\n  }\n\n  if (entityData.width) {\n    updateSize = true;\n    this.game.components.width.set(entityId, entityData.width);\n  }\n\n  if (entityData.radius) {\n    updateSize = true;\n    // this.game.components.radius.set(entityId, entityData.radius);\n  }\n\n  // size is new API, remove root level height, width, radius\n  if (entityData.size) {\n    updateSize = true;\n    this.game.components.size.set(entityId, entityData.size);\n  }\n\n  /*\n  if (entityData.body === false) {\n    // alert(\"remove body\");\n    this.game.physics.removeBody(entityId);\n  }\n  */\n\n  if (updateSize) {\n    // let body = this.game.bodyMap[entityId];\n    this.game.physics.setBodySize(entityId, entityData);\n\n  }\n\n  if (entityData.position) {\n\n    // update the position\n    this.game.components.position.set(entityId, entityData.position);\n\n    // let body = this.game.bodyMap[entityId];\n    this.game.physics.setPosition(entityId, entityData.position);\n\n  }\n\n  if (entityData.velocity) {\n    this.game.physics.setVelocity(entityId, entityData.velocity);\n  }\n\n  if (entityData.health) {\n    this.game.components.health.set(entityId, entityData.health);\n  }\n\n  if (typeof entityData.thickness !== 'undefined' && entityData.thickness !== null) {\n    this.game.components.width.set(entityId, entityData.thickness);\n  }\n\n  //\n  // Event handlers / Lifecycle Events\n  //\n\n  //\n  // Entity event lifecycle events will merge by default ( for now )\n  if (typeof entityData.update !== 'undefined') {\n    // get the current component value\n    let currentFn = this.game.components.update.get(entityId);\n    let entRef = this.game.data.ents._[entityId];\n    if (entRef) {\n      // clear out all existing update functions\n      // TODO: add better mappings in EntityBuilder.js for granular removals\n      if (entityData.update === null) {\n        this.game.components.update.set(entityId, null);\n      } else {\n        // create a quick config to store the events, we'll want to convert entire function to use this\n        let updateConfig = this.game.make();\n        updateConfig.onUpdate(entityData.update);\n        // inherit the current update function, creates a tree of functions\n        // do we want to do this? what are the implications?\n        if (currentFn && currentFn.handlers && currentFn.handlers.length) {\n          currentFn.handlers.forEach(function (fn) {\n            // console.log(\"adding existing fn to updateConfig\", fn.toString())\n            updateConfig.onUpdate(fn);\n          });\n        }\n        // console.log(\"new updateConfig\", updateConfig.config.update)\n        // Update the current ent that will be returned from updateEntity(entityId, entityData)\n        ent.update = updateConfig.config.update;\n        // Update the component value\n        this.game.components.update.set(entityId, updateConfig.config.update);\n      }\n    }\n  }\n\n  //\n  // UI Component Properties\n  //\n  if (typeof entityData.value !== 'undefined') {\n    this.game.components.value.set(entityId, entityData.value);\n  }\n\n  //\n  // Meta properties\n  //\n  if (typeof entityData.meta !== 'undefined') {\n    let merged = {};\n    let componentData = this.game.components.meta.get(entityId);\n    if (componentData) {\n      merged = { ...componentData, ...entityData.meta };\n    } else {\n      merged = entityData.meta;\n    }\n    this.game.components.meta.set(entityId, merged);\n  }\n\n  if (typeof entityData.score !== 'undefined' && entityData.score !== null) {\n    this.game.components.score.set(entityId, entityData.score);\n  }\n\n  if (typeof entityData.rotation !== 'undefined') {\n    if (this.game.physics && this.game.physics.setRotation) {\n      // let body = this.game.bodyMap[entityId];\n      this.game.physics.setRotation(entityId, entityData.rotation);\n\n    } else {\n      console.log('WARNING: physics.setRotation is not defined');\n      // Remark: we could support direct rotation updates here if mantra was being run without physics engine\n      // this.game.components.rotation.set(entityId, entityData.rotation);\n    }\n  }\n\n  if (typeof entityData.text !== 'undefined') {\n    this.game.components.text.set(entityId, entityData.text);\n  }\n\n  // Items\n  if (typeof entityData.items !== 'undefined') {\n    // overwrite all items ( for now )\n    // Remark: in the future we could merge instead of overwrite\n    this.game.components.items.set(entityId, entityData.items);\n  }\n\n  // Sutra rules\n  if (typeof entityData.sutra !== 'undefined') {\n    // overwrite sutra ( for now )\n    this.game.components.sutra.set(entityId, entityData.sutra);\n  }\n\n  // Items\n  if (typeof entityData.items !== 'undefined') {\n    // overwrite all items ( for now )\n    // Remark: in the future we could merge instead of overwrite\n    this.game.components.items.set(entityId, entityData.items);\n  }\n\n  if (typeof entityData.style !== 'undefined') {\n    // overwrite all items ( for now )\n    // Remark: in the future we could merge instead of overwrite\n    this.game.components.style.set(entityId, entityData.style);\n  }\n\n  if (typeof entityData.texture !== 'undefined') {\n    // overwrite all items ( for now )\n    // Remark: in the future we could merge instead of overwrite\n    // create new textures object by merging in the new texture\n    let prev = this.game.components.texture.get(entityId);\n    let newTexture;\n    // check to see if incoming entityData.texture is a string, if so, it's a texture id\n    if (typeof entityData.texture === 'string') {\n      newTexture = entityData.texture;\n    } else {\n      newTexture = { ...prev, ...entityData.texture };\n    }\n\n    this.game.components.texture.set(entityId, newTexture);\n  }\n\n  // Remark: The physics engine update will update the position\n  //         If we update the position here, it's most likely going to be overwritten by the physics engine\n  if (this.game.systems.rbush) {\n    // this.game.systems.rbush.updateEntity(ent);\n  }\n\n  // Updates the Entity.utick\n  this.game.components.utick.set(entityId, this.game.tick);\n\n  //\n  // Entity Lifecycle afterUpdateEntity\n  //\n\n  let updatedEnt = this.game.getEntity(entityId);\n\n  if (updateOptions.skipAfterUpdateEntity !== true) {\n    let _afterUpdateEntity;\n\n    if (typeof updatedEnt.afterUpdateEntity === 'function') {\n      _afterUpdateEntity = updatedEnt.afterUpdateEntity;\n    }\n    if (_afterUpdateEntity) {\n      _afterUpdateEntity(updatedEnt);\n    }\n  }\n\n  updatedEnt = this.game.lifecycle.triggerHook('after.updateEntity', updatedEnt);\n\n  return updatedEnt;\n\n}\n\n/* TODO: we need to iterate all events for composite updates\n   TODO: add unit tests for Entity.updateEntity({ eventName }) tests\n         be sure to check all cases\n         double check our usage of using null to pop fn from array\n         see about exact fn match for removal\n\nfunction updateEntityEvents(entityId, entityData) {\n  console.log(\"Updating Entity Events\");\n\n  // List of known event names\n  const eventNames = [\n    'pointerdown', 'pointerup', 'pointermove', 'pointerover', 'pointerout',\n    'pointerenter', 'pointerleave', 'collisionStart', 'collisionActive',\n    'collisionEnd', 'onDrop', 'update', 'afterRemoveEntity'\n  ];\n\n  let entRef = this.game.data.ents._[entityId];\n  if (!entRef) {\n    console.log(\"Entity reference not found\");\n    return;\n  }\n\n  eventNames.forEach(eventName => {\n    if (typeof entityData[eventName] !== 'undefined') {\n      console.log(`Processing ${eventName}`);\n\n      // Create a quick config to store the events\n      let eventConfig = this.game.make();\n\n      // Add the new event handler\n      eventConfig['_addEventHandler'](eventName, entityData[eventName]);\n\n      // Check if there are existing event handlers to preserve\n      let existingEventFn = this.game.components[eventName].get(entityId);\n      if (typeof existingEventFn === 'function' && Array.isArray(existingEventFn.handlers)) {\n        // Add each existing handler to the new configuration to preserve them\n        existingEventFn.handlers.forEach(handler => eventConfig['_addEventHandler'](eventName, handler));\n      }\n\n      // Set the updated configuration\n      this.game.components[eventName].set(entityId, eventConfig.config[eventName]);\n    }\n  });\n}\n*/","export default function removeAllEntities(options) {\n\n  // curry arguments, legacy API\n  let clearCurrentPlayer = false;\n  let excludeByName = [];\n  if (typeof options === 'boolean') {\n    clearCurrentPlayer = options;\n  }\n\n  if (typeof options === 'object' && Array.isArray(options.excludeByName)) {\n    excludeByName = options.excludeByName;\n  }\n\n  if (this.game.data.ents) {\n    for (let eId in this.game.data.ents._) {\n      let ent = this.game.data.ents._[eId];\n      // Do not remove the current player if clearCurrentPlayer is false\n      if (ent.id === this.game.currentPlayerId && !clearCurrentPlayer) {\n        continue;\n      }\n      // Do not remove entities that are excluded by name\n      if (excludeByName.includes(ent.name)) {\n        continue;\n      }\n      if (ent && ent.yCraft && ent.yCraft.part && ent.yCraft.part.unload) {\n        ent.yCraft.part.unload();\n      }\n      this.game.removeEntity(ent.id);\n    }\n  \n    if (clearCurrentPlayer) {\n      this.game.currentPlayerId = null;\n    }\n\n  }\n\n}","// Entity.js - Marak Squires 2023\nimport createEntity from './lib/createEntity.js';\nimport getEntity from './lib/getEntity.js';\nimport inflateEntity from './lib/inflateEntity.js';\nimport removeEntity from './lib/removeEntity.js';\nimport updateEntity from './lib/updateEntity.js';\nimport layoutEntity from './lib/layoutEntity.js';\nimport removeAllEntities from './lib/removeAllEntities.js';\n\nclass Entity {\n\n  static id = 'entity';\n  static removable = false;\n\n  constructor() {\n    this.id = Entity.id;\n    this.nextEntityId = 1; // 0 is reserved for server\n  }\n\n  init(bp) {\n\n    // bind game scope to this.bp\n    // TODO: game scope now becomes bp scope\n    this.bp = bp;\n\n    // init a new Map to store entities\n    bp.entities = new Map();\n\n    // does Entity need to register as a system?\n    // systems really only care about update() and maybe render()\n    // i think Entity proper doesn't care, only instances that are build will need to register?\n    // will have to double check and see\n    // this.bp.systemsManager.addSystem(this.id, this);\n\n    // Bind some methods to parent Game scope for convenience\n    // The most useful and common System methods are expected to be bound to Game\n    // This allows developers to customcraft a clean Game API based on their needs\n    this.bp.createEntity = createEntity.bind(this);\n    this.bp.getEntity = getEntity.bind(this);\n    this.bp.removeEntity = removeEntity.bind(this);\n    this.bp.getEntityByName = this.getEntityByName.bind(this);\n    this.bp.getEntities = this.allEntities.bind(this);\n    this.bp.updateEntity = updateEntity.bind(this);\n    this.bp.inflateEntity = inflateEntity.bind(this);\n    this.bp.hasEntity = this.hasEntity.bind(this);\n    this.bp.findEntity = this.findEntity.bind(this);\n    this.bp.removeAllEntities = removeAllEntities.bind(this);\n    this.removeAllEntities = removeAllEntities.bind(this);\n    this.layoutEntity = layoutEntity.bind(this);\n  }\n\n  hasEntity (entityId) {\n    return this.bp.entities.has(entityId);\n  }\n\n  findEntity (query) {\n    if (typeof query === 'string') {\n      query = { name: query };\n    }\n    // iterate over entities and return the first match\n    for (let [entityId, entity] of this.bp.entities) {\n      let match = true;\n      for (let key in query) {\n        if (entity[key] !== query[key]) {\n          match = false;\n          break;\n        }\n      }\n      if (match) {\n        return entity;\n      }\n    }\n  }\n\n  getEntityByName(name) {\n    for (let [entityId, entity] of this.bp.entities) {\n      if (entity.name === name) {\n        return entity;\n      }\n    }\n  }\n \n  _generateId() {\n    return this.nextEntityId++;\n  }\n\n  cleanupDestroyedEntities() {\n\n    this.bp.lifecycle.triggerHook('before.cleanupRemovedEntities');\n\n    const destroyedComponentData = this.bp.components.destroyed.data;\n    for (let entityId in destroyedComponentData) {\n      if (typeof entityId === 'string') {\n        entityId = parseInt(entityId); // for now, this can be removed when we switch Component.js to use Maps\n      }\n      const destroyedType = this.bp.components.type.get(entityId);\n      if (destroyedComponentData[entityId]) {\n        // Removes the body from the physics engine\n        if (typeof this.bp.physics.removeBody === 'function') {\n          this.bp.physics.removeBody(entityId);\n        }\n        // Delete associated components for the entity using Component's remove method\n        for (let componentType in this.bp.components) {\n          this.bp.components[componentType].remove(entityId);\n        }\n        this.bp.entities.delete(entityId);\n        // remove the reference in this.bp.data.ents\n        delete this.bp.data.ents._[entityId];\n        // find entity by id and filter it out\n        if (this.bp.data.ents[destroyedType]) {\n          // TODO: missing test ^^^\n          this.bp.data.ents[destroyedType] = this.bp.data.ents[destroyedType].filter((entity) => {\n            return Number(entity.id) !== Number(entityId);\n          });\n        }\n      }\n    }\n\n    this.bp.lifecycle.triggerHook('after.cleanupRemovedEntities');\n\n  }\n\n  // Update the getEntities method to return the game.entities\n  allEntities() {\n    return this.bp.entities;\n  }\n\n\n  applyLockedProperties(entityId, lockedProperties) {\n    // Check and apply locked properties\n    if (lockedProperties) {\n      console.log(\"Processing lockedProperties properties\");\n      for (let key in lockedProperties) {\n        let currentVal = this.bp.components[key].get(entityId);\n        console.log('currentVal', currentVal, 'key', key, lockedProperties)\n        if (currentVal !== undefined && currentVal !== null) {\n          if (typeof lockedProperties[key] === 'object' && !Array.isArray(lockedProperties[key])) {\n            // If lockedProperties[key] is an object, iterate through its keys\n            console.log('lockedProperties[key]', lockedProperties[key])\n            for (let subKey in lockedProperties[key]) {\n              console.log('subKey', subKey, lockedProperties[key][subKey])\n              if (lockedProperties[key][subKey] === true) {  // only process if the value is true\n                let nestedVal = currentVal[subKey];\n                if (nestedVal !== undefined && nestedVal !== null) {\n                  console.log('Setting lockedProperties property', `${key}.${subKey}`, 'to', nestedVal);\n                  this.bp.components['lockedProperties'].set(entityId, { [key]: { [subKey]: nestedVal } });\n                } else {\n                  console.log('Error: No such component or invalid value for', `${key}.${subKey}`);\n                }\n              }\n            }\n          } else if (lockedProperties[key] === true) {  // if lockedProperties[key] is not an object and the value is true\n            console.log('Setting lockedProperties property', key, 'to', currentVal);\n            this.bp.components['lockedProperties'].set(entityId, { [key]: currentVal });\n          }\n        } else {\n          console.log('Error: No such component or invalid value for', key);\n        }\n      }\n    }\n  }\n\n}\n\nexport default Entity;\n\n/* refactor to use this pattern */\n/*\nimport Entity from './Entity.js';\nconst entity = new Entity(entityId);\n\n*/\n","// Component.js - Marak Squires 2023\nclass Component {\n    constructor(name, game) {\n      this.name = name;\n      this.data = {};\n      this.game = game;\n    }\n  \n    set(key, value) {\n      const entityId = Array.isArray(key) ? key[0] : key;\n  \n      // Check if the property is locked\n      if (this.game) {\n        // console.log('this.game', this.game)\n        /*\n        const lockedProps = this.game.components['lockedProperties'].get(entityId);\n        if (this.isLocked(lockedProps, this.name)) {\n          // console.log(`Property ${key} is locked and cannot be updated.`);\n          return; // Do not update if the property is locked\n        }\n          */\n      }\n  \n      if (Array.isArray(key)) {\n        // Ensure nested structure exists\n        let current = this.data;\n        for (let i = 0; i < key.length - 1; i++) {\n          if (!current[key[i]]) {\n            current[key[i]] = {};\n          }\n          current = current[key[i]];\n        }\n        current[key[key.length - 1]] = value;\n      } else {\n        this.data[key] = value;\n      }\n  \n      // After setting the value, update the corresponding entity in the game.entities\n      if (this.game && this.game.entities && this.game.entities.has(entityId)) {\n        let existing = this.game.entities.get(entityId);\n        existing[this.name] = this.get(entityId);\n      }\n  \n    }\n  \n    get(key) {\n      if (Array.isArray(key)) {\n        let current = this.data;\n        for (let i = 0; i < key.length; i++) {\n          if (current[key[i]] === undefined) {\n            return null;\n          }\n          current = current[key[i]];\n        }\n        return current;\n      }\n  \n      if (typeof this.data[key] === 'undefined' || this.data[key] === null) {\n        return null;\n      }\n  \n      return this.data[key];\n    }\n  \n    remove(key) {\n      if (Array.isArray(key)) {\n        let current = this.data;\n        for (let i = 0; i < key.length - 1; i++) {\n          if (current[key[i]] === undefined) {\n            return;\n          }\n          current = current[key[i]];\n        }\n        delete current[key[key.length - 1]];\n      } else {\n        delete this.data[key];\n      }\n  \n    }\n  \n    // Helper method to check if a property or sub-property is locked\n    isLocked(lockedProps, key) {\n      if (!lockedProps) return false;\n  \n      if (Array.isArray(key)) {\n        let current = lockedProps;\n        for (let i = 0; i < key.length; i++) {\n          if (current[key[i]] === undefined) {\n            return false; // Property not locked\n          }\n          current = current[key[i]];\n        }\n        return true; // Property is locked\n      }\n  \n      return lockedProps[key] !== undefined;\n    }\n  \n  }\n  \n  export default Component;","import EntityClass from './EntityClass.js';\nimport Component from './Component.js';\n\nexport default class Entity {\n    constructor(bp, options = {}) {\n        this.bp = bp;\n        this.bp.components = {};\n        this.bp.addComponent = this.addComponent.bind(this);\n        this.bp.getComponent = this.getComponent.bind(this);\n\n        let _entity = new EntityClass(bp, options);\n        _entity.init(bp);\n        console.log('Entity created', _entity);\n\n\n        return this;\n    }\n\n    async init() {\n\n\n        return 'loaded entity';\n    }\n\n    addComponent(entityId, componentType, data) {\n\n        if (!this.bp.components[componentType]) {\n          this.bp.components[componentType] = new Component(componentType, this.bp);\n        }\n        // Initialize an empty map for the actionRateLimiter component\n        // TODO: remove this hard-coded check for actionRateLimiter\n        if (componentType === 'actionRateLimiter') {\n          data = new Map();\n        }\n    \n        if (data == null) {\n          return;\n        }\n    \n        this.bp.components[componentType].set(entityId, data);\n      }\n\n      getComponent(entityId, componentType) {\n        if (this.bp.components.hasOwnProperty(componentType)) {\n          return this.bp.components[componentType].get(entityId);\n        }\n        return null;\n      }\n    \n    \n}\n","import GameLoop from './GameLoop.js';\nimport entity from '../entity/entity.js';\n\nexport default class Game {\n    constructor(bp, options = {}) {\n        this.bp = bp;\n\n        new entity(bp).init();\n\n        let gameConfig = {\n            onlineGameLoopRunning: true,\n            graphics: ['css'],\n            physics: {},\n            systems: {},\n            entities: {},\n            ents: {},\n            data: {},\n            tick: 0,\n            removedEntities: new Set(),\n            changedEntities: new Set(),\n            currentPlayerId: null\n          };\n\n        let parent = null;\n\n        if (bp.apps && bp.apps.ui){\n            parent = bp.apps.ui.parent;\n        }\n        this.config = {\n            parent: parent, // should probably be a new window instead\n            game: gameConfig, // Your game instance\n            //hzMS: 16.666,\n            hzMS: 16.666,\n            fpsReportFrequency: 60,\n            gameWorker: '/v5/apps/based/game/gameWorker.js', // worker file that runs all your game logic\n            // once data is processed by the gameWorker, it sends it back to the main thread\n            // and then these methods are called\n            // inflateSnapshot and graphicsRender are currently hard-coded in GameLoop , but could be customized\n            inflateSnapshot: function noop () {}, // Your snapshot inflating function\n            graphicsRender: function noop () {} // Your graphics rendering function\n          };\n\n         \n\n    }\n\n    async init () {\n        this.gameLoop = new GameLoop(this.config, this.bp);\n        await this.gameLoop.init();\n        return this;\n    }\n\n    start () {\n        this.gameLoop.start();\n    }\n\n    stop () {\n        this.gameLoop.stop();\n    }\n    \n}"],"names":["async","getWorkerClass","window","Worker","import","GameLoop","constructor","config","bp","this","snapshots","game","started","lastRenderedSnapshotId","hzMS","accumulator","lastGameTick","Date","now","lastDelta","lastFPS","fpsMeasurements","fpsReportFrequency","frameCount","tickCount","init","worker","gameWorker","type","console","log","setupWorkerListeners","start","loop","stop","onlineGameLoopRunning","onmessage","event","payload","data","push","emit","fps","error","currentTime","deltaTime","calculateFPS","postMessage","length","shift","renderGraphics","requestAnimationFrame","bind","processWorkerUpdates","graphics","forEach","graphicsInterface","currentFPS","averageFPS","reduce","a","b","ensureColorInt","color","colorNameToHex","red","green","blue","black","white","yellow","purple","orange","pink","indigo","violet","startsWith","parseInt","replace","toLowerCase","layoutEntity","container","entityId","containerEnt","findEntity","Error","containerPosition","position","x","y","z","layoutType","origin","style","layout","meta","items","flexConfig","flex","map","itemId","getEntity","applyFlexLayout","call","gridConfig","grid","applyGridLayout","entity","offsetX","offsetY","size","width","height","cumulativeContainerPosition","newPosition","updateEntity","id","cols","columns","rows","containerItems","containerSize","cellWidth","cellHeight","item","index","row","Math","floor","col","positionX","positionY","itemPosition","skipAfterUpdateEntity","stackOffsetX","stackOffsetY","stackIndex","layoutConfig","flexDirection","justifyContent","alignItems","isRow","includes","mainSize","crossSize","mainStart","crossStart","mainAxisCurrentPosition","gridTemplateColumns","gridTemplateRows","split","ceil","createEntity","ignoreSetup","_generateId","defaultConfig","name","kind","body","shape","startingPosition","velocity","rotation","mass","density","health","Infinity","score","depth","lifetime","maxSpeed","isStatic","isSensor","restitution","sutra","scene","collectable","hasInventory","owner","source","inputs","value","destroyed","friction","frictionAir","frictionStatic","lockedProperties","actionRateLimiter","timers","yCraft","text","texture","collisionStart","collisionActive","collisionEnd","pointerdown","pointerup","pointermove","pointerover","pointerout","pointerenter","pointerleave","onDrop","afterItemCollected","afterRemoveEntity","afterCreateEntity","afterUpdate","update","exit","ctick","tick","utick","isNaN","radius","afterUpdateEntity","_sutra","ensuredColor","addComponent","rules","entities","set","_afterCreateEntity","updatedEntity","pendingRender","ents","_","PLAYER","Object","keys","setPlayerId","has","componentType","components","componentData","getComponent","inflateEntity","entityData","removeGraphic","removeEntity","removedEntities","get","updateOrCreate","charAt","toUpperCase","slice","defaultTypeConfig","make","build","p","err","defaultBuild","supportedSerializedEvents","eval","removeFromGameData","_afterRemoveEntity","ent","lifecycle","triggerHook","systems","timerId","removeTimer","rbush","deferredEntities","entityDataOrId","updateOptions","warn","getEntityByName","updateSize","physics","setBodySize","setPosition","setVelocity","thickness","currentFn","updateConfig","onUpdate","handlers","fn","merged","setRotation","newTexture","prev","updatedEnt","_afterUpdateEntity","removeAllEntities","options","clearCurrentPlayer","excludeByName","Array","isArray","eId","currentPlayerId","part","unload","Entity$1","Entity","static","nextEntityId","Map","getEntities","allEntities","hasEntity","query","match","key","cleanupDestroyedEntities","destroyedComponentData","destroyedType","removeBody","remove","delete","filter","Number","applyLockedProperties","currentVal","subKey","nestedVal","Component","current","i","undefined","isLocked","lockedProps","_entity","EntityClass","hasOwnProperty","Game","gameConfig","Set","changedEntities","parent","apps","ui","inflateSnapshot","graphicsRender","gameLoop"],"mappings":"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"}