{"version":3,"file":"fingerpaint.js","sources":["../../../apps/based/fingerpaint/fingerpaint.js"],"sourcesContent":["export default class FingerPaint {\n    constructor(bp, options = {}) {\n        this.bp = bp;\n        this.options = options;\n        this.isDrawing = false;\n        this.lastPos = null;\n        this.isErasing = false;\n        this.brushColor = 'rgba(255,255,255,0.9)';\n        this.brushSize = 12;\n        this.positionHistory = []; // For smoothing\n        this.maxHistory = 3; // Number of points to average for smoothing\n        return this;\n    }\n\n    async init() {\n        await this.bp.appendScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands');\n        await this.bp.appendScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils');\n        await this.bp.appendCSS('/v5/apps/based/fingerpaint/fingerpaint.css');\n        this.html = await this.bp.load('/v5/apps/based/fingerpaint/fingerpaint.html');\n        return 'loaded FingerPaint';\n    }\n\n    async open() {\n        this.win = this.bp.window(this.window());\n        this.startFingerPaint();\n        this.win.maximize();\n        return this.win;\n    }\n\n    window() {\n        const content = this.html;\n        return {\n            id: 'fingerpaint',\n            title: 'FingerPaint',\n            icon: 'desktop/assets/images/icons/icon_paint_64.png',\n            x: 300,\n            y: 100,\n            width: 700,\n            height: 520,\n            content,\n            parent: $('#desktop')[0],\n            resizable: true,\n            maximizable: true,\n            closable: true,\n        };\n    }\n\n    isFingerExtended(landmarks, tipIdx) {\n        const baseIdx = tipIdx - 2; // Knuckle\n        return landmarks[tipIdx].y < landmarks[baseIdx].y;\n    }\n\n    isHandOpen(landmarks) {\n        // Hand is open if index and middle fingers are extended\n        return this.isFingerExtended(landmarks, 8) && this.isFingerExtended(landmarks, 12);\n    }\n\n    isHandClosed(landmarks) {\n        // Hand is closed if index and middle fingers are not extended\n        return !this.isFingerExtended(landmarks, 8) && !this.isFingerExtended(landmarks, 12);\n    }\n\n    smoothPosition(newPos) {\n        this.positionHistory.push(newPos);\n        if (this.positionHistory.length > this.maxHistory) {\n            this.positionHistory.shift();\n        }\n\n        const avgPos = { x: 0, y: 0 };\n        this.positionHistory.forEach(pos => {\n            avgPos.x += pos.x;\n            avgPos.y += pos.y;\n        });\n        avgPos.x /= this.positionHistory.length;\n        avgPos.y /= this.positionHistory.length;\n        return avgPos;\n    }\n\n    async startFingerPaint() {\n        const video = document.getElementById('video');\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        const status = document.getElementById('status');\n        const overlayCanvas = document.getElementById('overlayCanvas');\n        const overlayCtx = overlayCanvas.getContext('2d');\n\n        // Keyboard controls for brush customization\n        document.addEventListener('keydown', (e) => {\n            switch (e.key.toLowerCase()) {\n                case 'r':\n                    this.brushColor = 'rgba(255,0,0,0.9)';\n                    status.innerText = `üñåÔ∏è Red Brush | R: Red, B: Blue, G: Green, +: Bigger, -: Smaller, C: Clear`;\n                    break;\n                case 'b':\n                    this.brushColor = 'rgba(0,0,255,0.9)';\n                    status.innerText = `üñåÔ∏è Blue Brush | R: Red, B: Blue, G: Green, +: Bigger, -: Smaller, C: Clear`;\n                    break;\n                case 'g':\n                    this.brushColor = 'rgba(0,255,0,0.9)';\n                    status.innerText = `üñåÔ∏è Green Brush | R: Red, B: Blue, G: Green, +: Bigger, -: Smaller, C: Clear`;\n                    break;\n                case '+':\n                    this.brushSize = Math.min(this.brushSize + 2, 30);\n                    status.innerText = `üñåÔ∏è Brush Size: ${this.brushSize}px | R: Red, B: Blue, G: Green, +: Bigger, -: Smaller, C: Clear`;\n                    break;\n                case '-':\n                    this.brushSize = Math.max(this.brushSize - 2, 4);\n                    status.innerText = `üñåÔ∏è Brush Size: ${this.brushSize}px | R: Red, B: Blue, G: Green, +: Bigger, -: Smaller, C: Clear`;\n                    break;\n                case 'c':\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    status.innerText = `üñåÔ∏è Canvas Cleared | R: Red, B: Blue, G: Green, +: Bigger, -: Smaller, C: Clear`;\n                    break;\n            }\n        });\n\n        const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n        video.srcObject = stream;\n        await new Promise(resolve => (video.onloadeddata = resolve));\n        video.play();\n\n        const hands = new Hands({\n            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`\n        });\n\n        hands.setOptions({\n            maxNumHands: 1,\n            modelComplexity: 1,\n            minDetectionConfidence: 0.7,\n            minTrackingConfidence: 0.7,\n            selfieMode: true\n        });\n\n        const camera = new Camera(video, {\n            onFrame: async () => await hands.send({ image: video }),\n            width: 640,\n            height: 480,\n        });\n        camera.start();\n\n        hands.onResults((results) => {\n            // ctx.drawImage(video, 0, 0, canvas.width, canvas.height); // Optional: Show webcam feed\n\n            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);\n\n\n            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {\n                this.lastPos = null;\n                this.positionHistory = [];\n                status.innerText = `üñåÔ∏è No hand detected | R: Red, B: Blue, G: Green, +: Bigger, -: Smaller, C: Clear`;\n                return;\n            }\n\n            const hand = results.multiHandLandmarks[0];\n            const tip = hand[8]; // Index finger tip\n            let x = tip.x * canvas.width;\n            let y = tip.y * canvas.height;\n\n            // Smooth the position\n            const smoothedPos = this.smoothPosition({ x, y });\n            x = smoothedPos.x;\n            y = smoothedPos.y;\n\n            // Check hand state\n            this.isErasing = [8, 12, 16, 20].every(tipIdx => this.isFingerExtended(hand, tipIdx));\n            const isHandOpen = this.isHandOpen(hand);\n            const isHandClosed = this.isHandClosed(hand);\n\n            // Set cursor appearance\n            ctx.beginPath();\n            ctx.arc(x, y, this.isErasing ? this.brushSize * 1.5 : this.brushSize / 2, 0, 2 * Math.PI); // Larger eraser cursor\n            if (isHandClosed) {\n\n                overlayCtx.beginPath();\n                overlayCtx.arc(x, y, this.brushSize / 2, 0, 2 * Math.PI);\n                overlayCtx.fillStyle = 'transparent';\n                overlayCtx.strokeStyle = 'rgba(128,128,128,0.5)'; // Gray outline\n                overlayCtx.lineWidth = 2;\n                overlayCtx.stroke();\n                status.innerText = `üñåÔ∏è Closed fist - not drawing | R: Red, B: Blue, G: Green, +: Bigger, -: Smaller, C: Clear`;\n\n                /*\n                ctx.fillStyle = 'transparent'; // No fill\n                ctx.strokeStyle = 'rgba(128,128,128,0.5)'; // Gray outline\n                ctx.lineWidth = 2;\n                ctx.stroke();\n\n                status.innerText = `üñåÔ∏è Closed fist - not drawing | R: Red, B: Blue, G: Green, +: Bigger, -: Smaller, C: Clear`;\n                */\n            } else if (this.isErasing) {\n                ctx.fillStyle = 'rgb(0,0,0)'; // Black for erasing\n                ctx.fill();\n                status.innerText = `üñåÔ∏è Erasing (Size: ${this.brushSize * 3}px) | R: Red, B: Blue, G: Green, +: Bigger, -: Smaller, C: Clear`;\n            } else {\n                ctx.fillStyle = this.brushColor; // Brush color for drawing\n                ctx.fill();\n                status.innerText = `üñåÔ∏è Drawing | R: Red, B: Blue, G: Green, +: Bigger, -: Smaller, C: Clear`;\n            }\n\n            // Set drawing mode\n            ctx.strokeStyle = this.isErasing ? 'black' : this.brushColor;\n            ctx.lineWidth = this.isErasing ? this.brushSize * 3 : this.brushSize; // Larger eraser stroke\n            ctx.lineJoin = 'round';\n            ctx.lineCap = 'round';\n\n            // Draw only if hand is open and not erasing\n            if (isHandOpen && !this.isErasing && this.lastPos) {\n                ctx.beginPath();\n                ctx.moveTo(this.lastPos.x, this.lastPos.y);\n                ctx.lineTo(x, y);\n                ctx.stroke();\n            }\n\n            // Update last position only if hand is open or erasing\n            this.lastPos = (isHandClosed) ? null : { x, y };\n        });\n    }\n}"],"names":["FingerPaint","constructor","bp","options","this","isDrawing","lastPos","isErasing","brushColor","brushSize","positionHistory","maxHistory","init","appendScript","appendCSS","html","load","open","win","window","startFingerPaint","maximize","id","title","icon","x","y","width","height","content","parent","$","resizable","maximizable","closable","isFingerExtended","landmarks","tipIdx","baseIdx","isHandOpen","isHandClosed","smoothPosition","newPos","push","length","shift","avgPos","forEach","pos","video","document","getElementById","canvas","ctx","getContext","status","overlayCanvas","overlayCtx","addEventListener","e","key","toLowerCase","innerText","Math","min","max","clearRect","stream","navigator","mediaDevices","getUserMedia","srcObject","Promise","resolve","onloadeddata","play","hands","Hands","locateFile","file","setOptions","maxNumHands","modelComplexity","minDetectionConfidence","minTrackingConfidence","selfieMode","Camera","onFrame","async","send","image","start","onResults","results","multiHandLandmarks","hand","tip","smoothedPos","every","beginPath","arc","PI","fillStyle","strokeStyle","lineWidth","stroke","fill","lineJoin","lineCap","moveTo","lineTo"],"mappings":"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"}