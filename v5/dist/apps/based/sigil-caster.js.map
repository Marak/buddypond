{"version":3,"file":"sigil-caster.js","sources":["../../../apps/based/sigil-caster/sigil-caster.js"],"sourcesContent":["export default class SigilCaster {\n    constructor(bp, options = {}) {\n        this.bp = bp;\n        this.options = options;\n        this.showDots = true;\n        this.path = []; // User-drawn path\n        this.lastPointTime = Date.now();\n        this.sigilTemplates = {}; // Store SVG path points\n        this.gestureLostFrames = 0;\n        this.gestureLostThreshold = 12; // adjust this value (e.g., ~6 = ~200ms buffer)\n\n        return this;\n    }\n\n    async init() {\n        await this.bp.appendScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs');\n        await this.bp.appendScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd');\n        await this.bp.appendScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands');\n        await this.bp.appendScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils');\n        await this.bp.appendScript('https://cdn.jsdelivr.net/npm/fingerpose/dist/fingerpose.min.js');\n        await this.bp.appendCSS('/v5/apps/based/sigil-caster/sigil-caster.css');\n\n        this.html = await this.bp.load('/v5/apps/based/sigil-caster/sigil-caster.html');\n\n        // Define point gesture\n        const { Finger, FingerCurl, GestureDescription } = fp;\n        const pointGesture = new GestureDescription('point');\n        pointGesture.addCurl(Finger.Index, FingerCurl.NoCurl, 1.0);\n        [Finger.Thumb, Finger.Middle, Finger.Ring, Finger.Pinky].forEach(finger => {\n            pointGesture.addCurl(finger, FingerCurl.FullCurl, 1.0);\n            pointGesture.addCurl(finger, FingerCurl.HalfCurl, 0.9);\n        });\n\n        this.GE = new fp.GestureEstimator([pointGesture]);\n        this.gestureEmoji = { 'point': '👈' };\n        this.spellMap = {\n            'lightning': {\n                spell: 'lightning',\n                type: 'sigil',\n                emoji: '⚡',\n                label: '⚡ Lightning ⚡',\n                svg: '/v5/apps/based/sigil-caster/sigils/lightning.svg'\n            },\n            'circle': {\n                spell: 'fireball',\n                type: 'sigil',\n                emoji: '🔥',\n                label: '🔥 Fireball 🔥',\n                svg: '/v5/apps/based/sigil-caster/sigils/circle.svg'\n            },\n            'cross': {\n                spell: 'flood',\n                type: 'sigil',\n                emoji: '❤️',\n                label: '❤️ Heal ❤️',\n                svg: '/v5/apps/based/sigil-caster/sigils/cross.svg'\n            },\n            'triangle': {\n                spell: 'barrelRoll',\n                type: 'sigil',\n                emoji: '🔺',\n                label: '🔺 Teleport 🔺',\n                svg: '/v5/apps/based/sigil-caster/sigils/triangle.svg'\n            },\n            'square': {\n                spell: 'earthquake',\n                type: 'sigil',\n                emoji: '🛡️',\n                label: '🛡️ Shield 🛡️',\n                svg: '/v5/apps/based/sigil-caster/sigils/square.svg'\n            },\n            'star': {\n                spell: 'peanut-butter-jelly-time',\n                type: 'sigil',\n                emoji: '⭐',\n                label: '⭐ Starburst ⭐',\n                svg: '/v5/apps/based/sigil-caster/sigils/star.svg'\n            },\n        };\n\n        // Create hidden container for SVG loading\n        this.svgContainer = document.createElement('div');\n        this.svgContainer.style.display = 'none';\n        document.body.appendChild(this.svgContainer);\n\n        // Load SVG templates\n        for (const [spell, meta] of Object.entries(this.spellMap)) {\n            if (meta.svg) {\n                console.log(`Loading SVG for ${spell}:`, meta.svg);\n                try {\n                    const response = await fetch(meta.svg);\n                    if (!response.ok) throw new Error(`HTTP ${response.status}`);\n                    const svgText = await response.text();\n                    console.log(`SVG text for ${spell}:`, svgText); // Debug log\n                    const parser = new DOMParser();\n                    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');\n                    const pathElement = svgDoc.querySelector('path');\n                    if (!pathElement) throw new Error('No path found in SVG');\n                    console.log('SVG path element:', pathElement); // Debug log\n                    this.sigilTemplates[spell] = this.extractPathPoints(pathElement.getAttribute('d'));\n\n                    console.log(`Loaded SVG for ${spell}:`, this.sigilTemplates[spell]);\n                } catch (error) {\n                    console.error(`Failed to load SVG for ${spell}:`, error);\n                }\n            }\n        }\n\n        this.hands = new Hands({\n            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`\n        });\n\n        this.hands.setOptions({\n            maxNumHands: 1,\n            modelComplexity: 1,\n            minDetectionConfidence: 0.85,\n            minTrackingConfidence: 0.85,\n            // selfieMode: true\n        });\n\n        return 'loaded SigilCaster';\n    }\n\n    async open() {\n        if (this.win) {\n            this.win.focus();\n            return this.win;\n        }\n\n        this.win = this.bp.window(this.window());\n\n        document.getElementById('toggle-dots-btn').onclick = () => {\n            this.showDots = !this.showDots;\n            $('.spell-guide', this.win.content).toggle();\n        };\n\n        this.renderSpellGuide(this.spellMap);\n\n        const startFakeLoadingSequence = () => {\n            const steps = [\n                \"Initializing camera...\",\n                \"Loading vision model...\",\n                \"Calibrating finger tracking...\",\n                \"Syncing sigil detector...\",\n                \"Finalizing setup...\"\n            ];\n            let stepIndex = 0;\n            const $loadingText = $('#loading-text', this.win.content);\n            const interval = setInterval(() => {\n                $loadingText.text(steps[stepIndex]);\n                stepIndex++;\n                if (stepIndex >= steps.length) {\n                    clearInterval(interval);\n                }\n            }, 1200);\n        };\n        startFakeLoadingSequence.call(this);\n\n        this.startObjectDetection();\n        this.win.maximize();\n        return this.win;\n    }\n\n    window() {\n        return {\n            id: 'sigil-caster',\n            title: 'Sigil Caster',\n            icon: 'desktop/assets/images/icons/icon_sigil-caster_64.png',\n            x: 250,\n            y: 75,\n            width: 600,\n            height: 400,\n            minWidth: 400,\n            minHeight: 300,\n            parent: $('#desktop')[0],\n            content: this.html,\n            resizable: true,\n            minimizable: true,\n            maximizable: true,\n            closable: true,\n            focusable: true,\n            maximized: false,\n            minimized: false,\n            onClose: () => {\n                this.win = null;\n                if (this.video) {\n                    this.video.srcObject.getTracks().forEach(track => track.stop());\n                    this.video = null;\n                }\n            }\n        };\n    }\n\n    async startObjectDetection() {\n        const video = document.getElementById('video');\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n\n        const model = await cocoSsd.load();\n        const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n        video.srcObject = stream;\n        this.video = video;\n\n        await new Promise(resolve => video.onloadeddata = resolve);\n        video.play();\n        video.style.display = 'none';\n\n        let foundFirstSigil = false;\n        setTimeout(() => {\n            if (!foundFirstSigil) {\n                $('.instruction-overlay', this.win.content).hide();\n                foundFirstSigil = true;\n            }\n        }, 10000);\n\n        let firstResult = false;\n\n        this.hands.onResults(async (results) => {\n            if (!firstResult) {\n                firstResult = true;\n                $('.cv-loading', this.win.content).hide();\n            }\n\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.save();\n            ctx.scale(-1, 1);\n            ctx.translate(-canvas.width, 0);\n            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n            ctx.restore();\n\n            const sigilTrailEl = document.getElementById('sigil-trail');\n            const sigilSpellEl = document.getElementById('sigil-spell');\n            const now = Date.now();\n\n            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {\n                const landmarks = results.multiHandLandmarks[0].map(p => [p.x, p.y, p.z]);\n                const est = this.GE.estimate(landmarks, 8.5);\n\n                if (est.gestures.length > 0 && est.gestures[0].name === 'point') {\n                    this.gestureLostFrames = 0;\n\n                    const indexTip = results.multiHandLandmarks[0][8];\n                    const x = indexTip.x * canvas.width;\n                    const y = indexTip.y * canvas.height;\n\n                    if (now - this.lastPointTime > 100) {\n                        this.path.push({ x, y });\n                        this.lastPointTime = now;\n                    }\n\n                    if (this.path.length > 200) this.path.shift();\n\n                    // Draw path...\n                    ctx.save();\n                    ctx.scale(-1, 1);\n                    ctx.translate(-canvas.width, 0);\n                    ctx.beginPath();\n                    ctx.strokeStyle = 'cyan';\n                    ctx.lineWidth = 3;\n                    for (let i = 1; i < this.path.length; i++) {\n                        ctx.moveTo(this.path[i - 1].x, this.path[i - 1].y);\n                        ctx.lineTo(this.path[i].x, this.path[i].y);\n                    }\n                    ctx.stroke();\n                    ctx.restore();\n\n                    sigilTrailEl.textContent = `Sigil: Drawing (${this.path.length} points)`;\n\n                    const matchedSpell = this.detectSigil(this.path);\n                    if (matchedSpell) {\n                        this.castSpell(matchedSpell, sigilSpellEl);\n                        this.path = [];\n                        sigilTrailEl.textContent = 'Sigil: ';\n                        foundFirstSigil = true;\n                        $('.instruction-overlay', this.win.content).hide();\n                    }\n                } else {\n                    if (this.path.length > 0) {\n                        this.gestureLostFrames++;\n                        if (this.gestureLostFrames > this.gestureLostThreshold) {\n                            this.path = [];\n                            this.gestureLostFrames = 0;\n                            sigilTrailEl.textContent = 'Sigil: ';\n                            console.log('Path reset: Point gesture lost for too long');\n                        } else {\n                            console.log(`Gesture temporarily lost (${this.gestureLostFrames})`);\n                        }\n                    }\n                }\n\n                if (this.showDots && results.multiHandLandmarks[0]) {\n                    ctx.save();\n                    ctx.scale(-1, 1);\n                    ctx.translate(-canvas.width, 0);\n                    for (const lm of results.multiHandLandmarks[0]) {\n                        const x = lm.x * canvas.width;\n                        const y = lm.y * canvas.height;\n                        ctx.beginPath();\n                        ctx.arc(x, y, 4, 0, 2 * Math.PI);\n                        ctx.fillStyle = 'cyan';\n                        ctx.fill();\n                    }\n                    ctx.restore();\n                }\n            } else {\n                if (this.path.length > 0) {\n                    this.path = [];\n                    sigilTrailEl.textContent = 'Sigil: ';\n                    console.log('Path reset: No hand detected');\n                }\n            }\n\n            const predictions = await model.detect(video);\n            const listEl = $('#object-list', this.win.content)[0];\n            listEl.innerHTML = '';\n            predictions.forEach(pred => {\n                const [x, y, width, height] = pred.bbox;\n                if (this.showDots) {\n                    ctx.save();\n                    ctx.scale(-1, 1);\n                    ctx.translate(-canvas.width, 0);\n                    ctx.beginPath();\n                    ctx.rect(x, y, width, height);\n                    ctx.lineWidth = 2;\n                    ctx.strokeStyle = 'red';\n                    ctx.fillStyle = 'red';\n                    ctx.stroke();\n                    ctx.fillText(pred.class, x, y > 10 ? y - 5 : 10);\n                    ctx.restore();\n                }\n                const li = document.createElement('li');\n                li.textContent = `${pred.class} (${(pred.score * 100).toFixed(1)}%)`;\n                listEl.appendChild(li);\n            });\n        });\n\n        const camera = new Camera(video, {\n            onFrame: async () => {\n                canvas.width = video.videoWidth;\n                canvas.height = video.videoHeight;\n                await this.hands.send({ image: video });\n            },\n            width: 640,\n            height: 480\n        });\n\n        camera.start();\n    }\n\n    extractPathPoints(d) {\n        const commands = d.match(/[ML][^ML]+/g);\n        if (!commands) return [];\n\n        const points = commands\n            .map(cmd => cmd.trim().slice(1).trim().split(/[ ,]+/).map(Number))\n            .filter(pair => pair.length === 2)\n            .map(([x, y]) => ({ x, y }));\n\n        const bounds = this.getBounds(points);\n        return points.map(p => ({\n            x: (p.x - bounds.minX) / (bounds.maxX - bounds.minX || 1),\n            y: (p.y - bounds.minY) / (bounds.maxY - bounds.minY || 1)\n        }));\n    }\n\n\n\n    getBounds(points) {\n        return points.reduce(\n            (b, p) => ({\n                minX: Math.min(b.minX, p.x),\n                maxX: Math.max(b.maxX, p.x),\n                minY: Math.min(b.minY, p.y),\n                maxY: Math.max(b.maxY, p.y)\n            }),\n            { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity }\n        );\n    }\n\n    detectSigil(path) {\n        if (path.length < 10) return null;\n\n        // Smooth noisy path\n        const smoothed = this.smoothPath(path, 3);\n\n        // Normalize to [0, 1] space\n        const bounds = this.getBounds(smoothed);\n        const boundsArea = (bounds.maxX - bounds.minX) * (bounds.maxY - bounds.minY);\n        if (boundsArea < 0.01) return null; // Reject too-small gestures\n\n        const normalizedPath = smoothed.map(p => ({\n            x: (p.x - bounds.minX) / (bounds.maxX - bounds.minX),\n            y: (p.y - bounds.minY) / (bounds.maxY - bounds.minY)\n        }));\n\n        // Frame-to-frame matching buffer\n        this.matchBuffer = this.matchBuffer || {};\n\n        for (const [spell, template] of Object.entries(this.sigilTemplates)) {\n            if (template.length < 2) continue;\n\n            const distance = Math.min(\n                this.comparePaths(normalizedPath, template),\n                this.comparePaths(normalizedPath, [...template].reverse())\n            );\n\n            // Adaptive threshold: tighter for longer paths\n            const adaptiveThreshold = Math.max(0.12, 0.35 - 0.0015 * normalizedPath.length);\n\n            // Keep track of match streak\n            if (!this.matchBuffer[spell]) this.matchBuffer[spell] = 0;\n            if (distance < adaptiveThreshold) {\n                this.matchBuffer[spell]++;\n                if (this.matchBuffer[spell] >= 3) { // Require 3 consecutive frames\n                    this.matchBuffer = {}; // reset buffer\n                    return spell;\n                }\n            } else {\n                this.matchBuffer[spell] = 0;\n            }\n        }\n\n        return null;\n    }\n\n    smoothPath(path, windowSize = 3) {\n        const smoothed = [];\n        const half = Math.floor(windowSize / 2);\n        for (let i = 0; i < path.length; i++) {\n            let sumX = 0, sumY = 0, count = 0;\n            for (let j = -half; j <= half; j++) {\n                const p = path[i + j];\n                if (p) {\n                    sumX += p.x;\n                    sumY += p.y;\n                    count++;\n                }\n            }\n            smoothed.push({ x: sumX / count, y: sumY / count });\n        }\n        return smoothed;\n    }\n\n\n    comparePaths(path1, path2) {\n        // Resample paths to same length for comparison\n        const n = Math.min(50, Math.max(path1.length, path2.length));\n        const resampled1 = this.resamplePath(path1, n);\n        const resampled2 = this.resamplePath(path2, n);\n\n        // Calculate average point-to-point distance\n        let totalDistance = 0;\n        for (let i = 0; i < n; i++) {\n            const dx = resampled1[i].x - resampled2[i].x;\n            const dy = resampled1[i].y - resampled2[i].y;\n            totalDistance += Math.sqrt(dx * dx + dy * dy);\n        }\n        return totalDistance / n;\n    }\n\n    resamplePath(path, n) {\n        if (path.length < 2) return path;\n        const totalLength = path.slice(1).reduce((len, p, i) => {\n            const prev = path[i];\n            return len + Math.sqrt((p.x - prev.x) ** 2 + (p.y - prev.y) ** 2);\n        }, 0);\n\n        const resampled = [path[0]];\n        const step = totalLength / (n - 1);\n        let currentLength = 0;\n        let index = 0;\n\n        for (let i = 1; i < n - 1; i++) {\n            const targetLength = i * step;\n            while (index < path.length - 1 && currentLength < targetLength) {\n                const p1 = path[index];\n                const p2 = path[index + 1];\n                const segmentLength = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n                currentLength += segmentLength;\n                index++;\n            }\n            if (index >= path.length) break;\n\n            const p1 = path[index - 1];\n            const p2 = path[index];\n            const segmentLength = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n            const t = (targetLength - (currentLength - segmentLength)) / segmentLength;\n            resampled.push({\n                x: p1.x + t * (p2.x - p1.x),\n                y: p1.y + t * (p2.y - p1.y)\n            });\n        }\n        if (path.length > 0) resampled.push(path[path.length - 1]);\n        return resampled;\n    }\n\n    async castSpell(spellName, sigilSpellEl) {\n        const spellMeta = this.spellMap[spellName];\n        if (!spellMeta) return;\n\n        console.log(`⚡ Sigil Cast: ${spellMeta.spell.charAt(0).toUpperCase() + spellMeta.spell.slice(1)}!`);\n        // this.bp.toast(spellMeta.label);\n        sigilSpellEl.innerHTML = spellMeta.label;\n\n        try {\n            const spellModule = await this.bp.importModule(\n                `/v5/apps/based/spellbook/spells/${spellMeta.spell}/${spellMeta.spell}.js`, {}, false\n            );\n            spellModule.default.call(this);\n        } catch (error) {\n            console.error('Error importing spell module:', error);\n        }\n\n        setTimeout(() => {\n            sigilSpellEl.innerHTML = '';\n        }, 2200);\n    }\n\n    renderSpellGuide(spellMap) {\n        const $list = $('#spell-list', this.win.content);\n        for (const [spell, info] of Object.entries(spellMap)) {\n            $list.append(`<li>${info.label} (Draw ${spell})</li>`);\n        }\n    }\n}"],"names":["SigilCaster","constructor","bp","options","this","showDots","path","lastPointTime","Date","now","sigilTemplates","gestureLostFrames","gestureLostThreshold","init","appendScript","appendCSS","html","load","Finger","FingerCurl","GestureDescription","fp","pointGesture","addCurl","Index","NoCurl","Thumb","Middle","Ring","Pinky","forEach","finger","FullCurl","HalfCurl","GE","GestureEstimator","gestureEmoji","point","spellMap","lightning","spell","type","emoji","label","svg","circle","cross","triangle","square","star","svgContainer","document","createElement","style","display","body","appendChild","meta","Object","entries","console","log","response","fetch","ok","Error","status","svgText","text","parser","DOMParser","pathElement","parseFromString","querySelector","extractPathPoints","getAttribute","error","hands","Hands","locateFile","file","setOptions","maxNumHands","modelComplexity","minDetectionConfidence","minTrackingConfidence","open","win","focus","window","getElementById","onclick","$","content","toggle","renderSpellGuide","steps","stepIndex","$loadingText","interval","setInterval","length","clearInterval","call","startObjectDetection","maximize","id","title","icon","x","y","width","height","minWidth","minHeight","parent","resizable","minimizable","maximizable","closable","focusable","maximized","minimized","onClose","video","srcObject","getTracks","track","stop","canvas","ctx","getContext","model","cocoSsd","stream","navigator","mediaDevices","getUserMedia","Promise","resolve","onloadeddata","play","foundFirstSigil","setTimeout","hide","firstResult","onResults","async","results","clearRect","save","scale","translate","drawImage","restore","sigilTrailEl","sigilSpellEl","multiHandLandmarks","landmarks","map","p","z","est","estimate","gestures","name","indexTip","push","shift","beginPath","strokeStyle","lineWidth","i","moveTo","lineTo","stroke","textContent","matchedSpell","detectSigil","castSpell","lm","arc","Math","PI","fillStyle","fill","predictions","detect","listEl","innerHTML","pred","bbox","rect","fillText","class","li","score","toFixed","Camera","onFrame","videoWidth","videoHeight","send","image","start","d","commands","match","points","cmd","trim","slice","split","Number","filter","pair","bounds","getBounds","minX","maxX","minY","maxY","reduce","b","min","max","Infinity","smoothed","smoothPath","normalizedPath","matchBuffer","template","distance","comparePaths","reverse","adaptiveThreshold","windowSize","half","floor","sumX","sumY","count","j","path1","path2","n","resampled1","resamplePath","resampled2","totalDistance","dx","dy","sqrt","totalLength","len","prev","resampled","step","currentLength","index","targetLength","p1","p2","segmentLength","t","spellName","spellMeta","charAt","toUpperCase","importModule","default","$list","info","append"],"mappings":"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"}