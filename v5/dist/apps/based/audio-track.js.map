{"version":3,"file":"audio-track.js","sources":["../../../apps/based/audio-track/render/defaultRender.js","../../../apps/based/fetch-in-webworker/WebWorkerFetchWithProgress.js","../../../apps/based/fetch-in-webworker/fetch-in-webworker.js","../../../apps/based/audio-track/load.js","../../../apps/based/audio-track/AudioTrack.js","../../../apps/based/audio-track/lib/setBPM.js","../../../apps/based/audio-track/audio-track.js"],"sourcesContent":["export default function defaultRender(track) {\n    const container = document.createElement('div');\n    container.className = 'audio-track';\n  \n    const fileName = document.createElement('p');\n    fileName.textContent = track.metadata.fileName || 'No file loaded';\n    container.appendChild(fileName);\n\n    const playPauseButton = document.createElement('button');\n    playPauseButton.textContent = 'Play';\n    playPauseButton.addEventListener('click', () => {\n        console.log('playPauseButton clicked', track.isPlaying());\n      if (track.isPlaying()) {\n        track.pause();\n        playPauseButton.textContent = 'Play';\n      } else {\n        track.play();\n        playPauseButton.textContent = 'Pause';\n      }\n    });\n    \n    container.appendChild(playPauseButton);\n  \n    return container;\n}","export default class WebworkerFetchWithProgress {\n    constructor(workerScript = 'workerFetchWithProgress.js') {\n        this.worker = new Worker(workerScript);\n        this.requests = {};\n\n        this.worker.onmessage = (event) => {\n            const { type, id, progress, data, error } = event.data;\n            const request = this.requests[id];\n            if (!request) return; // onProgress never happens since request is not defined until fetch is called?\n            switch (type) {\n                case 'progress':\n                    if (request.onProgress) {\n                        request.onProgress(progress); // Call progress callback\n                    }\n                    break;\n                case 'completed':\n                    if (request.resolve) {\n                        request.resolve(event.data); // Resolve the promise\n                    }\n                    delete this.requests[id]; // Clean up\n                    break;\n                case 'error':\n                    if (request.reject) {\n                        request.reject(error); // Reject the promise\n                    }\n                    delete this.requests[id]; // Clean up\n                    break;\n            }\n        };\n    }\n\n    fetch(url, options = {}, onProgress) {\n        const id = Math.random().toString(36).substr(2, 9); // Generate unique ID\n        this.requests[id] = { onProgress, id };\n        return new Promise((resolve, reject) => {\n            this.requests[id].resolve = resolve;\n            this.requests[id].reject = reject;\n            this.worker.postMessage({ url, options, id }); // Start the fetch process\n        });\n    }\n}","import WebworkerFetchWithProgress from \"./WebWorkerFetchWithProgress.js\";\n\nexport default class FetchInWebWorker {\n    constructor(bp) {\n        this.bp = bp;\n\n        return this;\n\n    }\n\n    async init() {\n    }\n\n    async fetchWithProgress(url, options = {}, onProgress) {\n        const fetcher = new WebworkerFetchWithProgress();\n        return fetcher.fetch(url, options, onProgress);\n    }\n}","import FetchInWebWorker from '../fetch-in-webworker/fetch-in-webworker.js';\n\n//await this.bp.appendScript('/v5/apps/based/audio-track/vendor/ffmpeg/ffmpeg/package/dist/umd/ffmpeg.js');\n//await this.bp.appendScript('/v5/apps/based/audio-track/vendor/ffmpeg/util/package/dist/umd/index.js');\n\n\n//import { FFmpeg } from \"/v5/apps/based/audio-track/vendor/ffmpeg/ffmpeg/package/dist/esm/index.js\";\n//import { fetchFile } from \"/v5/apps/based/audio-track/vendor/ffmpeg/util/package/dist/esm/index.js\";\n\n// HTTP Provider implementation\nclass HTTPAudioProvider {\n    constructor(bp) {\n        this.bp = bp;\n        this.fetchInWebWorker = new FetchInWebWorker();\n\n    }\n\n    async loadAudioData(url, options = {}, onProgress = () => { }) {\n        // Ensure HTTP protocol ???\n        // url = url.replace('https', 'http');\n                /* \n        const response = await fetch(url, options);\n        // make a copy of response so we can parse it twice\n        const responseCopy = response.clone();\n        console.log('response', response);\n        let blob = await response.blob();\n        let arrayBuffer = await responseCopy.arrayBuffer();\n        console.log('arrayBuffer', arrayBuffer);\n        console.log('blob', blob);\n        return { arrayBuffer, blob };\n       */\n        const response = await this.fetchInWebWorker.fetchWithProgress(\n            url,\n            {},\n            onProgress\n        );\n\n        return {\n            arrayBuffer: response.arrayBufferResponse,\n            blob: response.blobResponse\n        };\n    }\n}\n\n\nexport default function bindPrototypeMethods(AudioTrack) {\n\n    AudioTrack.prototype.load = async function (options = {}) {\n        if (this.options?.noFile) return this;\n    \n        if (options.url) {\n            this.metadata.url = options.url;\n        }\n\n        try {\n    \n            // Ensure we have a provider\n            if (!this.provider) {\n                this.provider = new HTTPAudioProvider(this.bp);\n            }\n            console.log(\"Loading audio track:\", this.metadata.url, this);\n    \n            // Load audio data from provider\n            const { arrayBuffer, blob } = await this.provider.loadAudioData(\n                this.metadata.url,\n                options,\n                (progress) => this.loadingProgress(progress)\n            );\n    \n            // Decode and process audio\n            await this._processAudioData(arrayBuffer, blob);\n    \n            // Setup media source and handle platform-specific loading\n            return await this._setupMediaSource(blob);\n        } catch (error) {\n            console.error(`Failed to load track: ${this.metadata.url}`, error);\n            throw error;\n        }\n    };\n    \n    AudioTrack.prototype._setupMediaSource = async function (blob) {\n        return new Promise(async (resolve, reject) => {\n            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n    \n            if (isIOS) {\n                // Directly use blob URL for iOS\n                this.audioElement.src = URL.createObjectURL(blob);\n                this.audioElement.addEventListener(\"canplaythrough\", () => {\n                    // set the duration on t.metadata.duration\n                    this.metadata.duration = this.audioElement.duration;\n                    resolveLoad();\n                });\n                this.audioElement.addEventListener(\"error\", rejectLoad);\n            } else {\n                // Use MediaSource for other platforms\n                const mediaSource = new MediaSource();\n                this.audioElement.src = URL.createObjectURL(mediaSource);\n    \n                mediaSource.addEventListener(\"sourceopen\", async () => {\n                    try {\n                        const sourceBuffer = mediaSource.addSourceBuffer(\"audio/mpeg\");\n                        const arrayBuffer = await blob.arrayBuffer();\n                        // set the duration on t.metadata.duration\n                        this.metadata.duration = this.audioBuffer.duration;\n                        sourceBuffer.addEventListener(\"updateend\", resolveLoad);\n                        sourceBuffer.addEventListener(\"error\", rejectLoad);\n                        sourceBuffer.appendBuffer(arrayBuffer);\n                    } catch (err) {\n                        console.error(\"Error with MediaSource or SourceBuffer:\", err);\n                        rejectLoad(err);\n                    }\n                });\n            }\n    \n            const resolveLoad = () => {\n                if (this.isLoaded) return;\n                this.isLoaded = true;\n                console.log(\"Track loaded:\", this.metadata.url);\n                resolve(this);\n            };\n    \n            const rejectLoad = (err) => {\n                console.error(\"Audio element error:\", err);\n                reject(`Failed to load track: ${this.metadata.url}`);\n            };\n    \n            // Load and setup the media if not using MediaSource\n            if (isIOS || (this.url && this.url.endsWith('.wav'))) {\n                this.audioElement.load();\n            }\n        });\n    };\n    \n    AudioTrack.prototype._initializeAudioElements = function () {\n        this.audioElement = new Audio();\n        this.audioElement.crossOrigin = \"anonymous\";\n        this.audioElement.preservesPitch = true;\n    };\n\n    AudioTrack.prototype._processAudioData = async function (arrayBuffer, blob) {\n        this.audioData = arrayBuffer;\n        this.blob = blob;\n        console.log('Audio data received:', this.audioData);\n    \n        // Decode using Web Worker\n        // this.audioBuffer = await this._decodeAudioWithFFmpeg(arrayBuffer);\n        // decode with audioContext\n        this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\n        this.metadata.fileSize = this.audioBuffer.length;\n    \n        // Extract channel data\n        const channelData = extractAudioBuffer(this.audioBuffer);\n    };\n    AudioTrack.prototype._decodeAudioWithFFmpeg = async function (arrayBuffer) {\n\n        let ffmpeg = new FFmpeg();\n\n            await ffmpeg.load();\n            console.log(\"✅ FFmpeg WASM loaded successfully\");\n    \n        return new Promise(async (resolve, reject) => {\n            try {\n                console.log(\"⏳ Decoding audio with FFmpeg...\");\n    \n                // Write audio data into FFmpeg virtual filesystem\n                const inputFileName = 'input.mp3';\n                const outputFileName = 'output.raw';\n                await ffmpeg.writeFile(inputFileName, await fetchFile(arrayBuffer));\n    \n                // Convert input audio to raw PCM Float32\n                await ffmpeg.exec([\n                    '-i', inputFileName, \n                    '-f', 'f32le', \n                    '-acodec', 'pcm_f32le', \n                    '-ar', '44100', // Force 44.1kHz sample rate\n                    '-ac', '2', // Stereo output\n                    outputFileName\n                ]);\n    \n                // Read decoded PCM data\n                const outputData = await ffmpeg.readFile(outputFileName);\n    \n                // Convert PCM data to Web Audio API's AudioBuffer\n                const sampleRate = 44100; // Match conversion settings\n                const numberOfChannels = 2; // Stereo\n                const frameCount = outputData.length / (numberOfChannels * 4); // 4 bytes per Float32 sample\n    \n                const audioContext = new AudioContext();\n                const audioBuffer = audioContext.createBuffer(numberOfChannels, frameCount, sampleRate);\n    \n                // De-interleave PCM data into separate channels\n                const interleaved = new Float32Array(outputData.buffer);\n                for (let i = 0; i < numberOfChannels; i++) {\n                    const channelData = new Float32Array(frameCount);\n                    for (let j = 0; j < frameCount; j++) {\n                        channelData[j] = interleaved[j * numberOfChannels + i];\n                    }\n                    audioBuffer.copyToChannel(channelData, i);\n                }\n    \n                console.log(\"✅ Audio decoded successfully\");\n                resolve(audioBuffer);\n            } catch (err) {\n                console.log(err)\n                reject(new Error(`❌ FFmpeg decoding failed: ${err.message}`));\n            }\n        });\n    };\n    \n\n    /*\n    TODO: use the audioWOrker instead of the audioContext.decodeAudioData\n    const audioWorker = new Worker('audioWorker.js');\n\nfunction decodeAudioWithFFmpeg(arrayBuffer) {\n    return new Promise((resolve, reject) => {\n        audioWorker.onmessage = (e) => {\n            if (e.data.error) {\n                reject(new Error(e.data.error));\n            } else {\n                resolve(e.data);\n            }\n        };\n        audioWorker.postMessage(arrayBuffer, [arrayBuffer]); // Transfer data\n    });\n}\n\n// Example usage:\nfetch('your-audio-file.mp3')\n    .then(response => response.arrayBuffer())\n    .then(arrayBuffer => decodeAudioWithFFmpeg(arrayBuffer))\n    .then(decodedData => {\n        console.log('Decoded WAV received:', decodedData);\n        // Use AudioContext.decodeAudioData here if needed\n    })\n    .catch(err => console.error('FFmpeg decoding failed:', err));\n\n\n\n    */\n\n    \n    // Helper methods for tracking load progress\n    AudioTrack.prototype.loadingProgress = function (progress) {\n        // Implement loading progress updates\n        this.emit('audio-track::loading::progress', progress);\n    };\n\n    AudioTrack.prototype.loadingComplete = function (progress) {\n        // Implement loading completion\n        this.emit('audio-track::loading::complete', progress);\n    };\n\n}\n\n\n// Extract channel data from AudioBuffer\nfunction extractAudioBuffer(audioBuffer) {\n    const channelData = [];\n    for (let i = 0; i < audioBuffer.numberOfChannels; i++) {\n        channelData.push(audioBuffer.getChannelData(i));\n    }\n    return channelData;\n}\n","import defaultRender from './render/defaultRender.js';\nimport load from './load.js';\n\nimport setBPM from './lib/setBPM.js';\n\nexport default class Track {\n  constructor(options = {}) {\n    this.id = options.id || `track-${Math.random().toString(36).substr(2, 9)}`;\n    this.metadata = options || {};\n    this.metadata.cuePoints = this.metadata.cuePoints || [];\n    this.provider = options.provider || null;\n\n    // Audio properties\n    this.source = null;\n    this.audioNodes = new Map();\n\n    // UI properties\n    this.element = null;\n    this.renderers = new Map();\n    this.currentRenderer = 'default';\n\n    // State\n    this.isLoaded = false;\n    this.isRendered = false;\n\n    load(Track);\n\n    // Event Listeners\n    this.eventListeners = {};\n\n    // Audio Graph / FX\n    this.fx = {};\n\n    // Setup initial audio elements\n    this._initializeAudioElements();\n\n    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\n    this.masterBus = this.audioContext.createGain(); // Create a gain node as the master bus\n    this.distributionNode = this.audioContext.createGain(); // Node for distribution\n\n\n    // Connect nodes\n    this.source = this.audioContext.createMediaElementSource(this.audioElement);\n    this.source.disconnect();\n    this.source.connect(this.masterBus);\n\n\n    // Setup basic audio path\n    this.masterBus.connect(this.distributionNode); // Connect master bus to distribution node\n    this.distributionNode.connect(this.audioContext.destination); // Connect to output\n\n    // Distribution node doesn't alter the signal\n    this.distributionNode.gain.value = 1;\n\n    // Initialize a map to hold analyzers\n    this.analyzers = new Map();\n\n\n    // this.addAnalyzer('master', this.audioContext.createAnalyser()); // Create a master analyzer\n\n    /*\n   this.analyser = this.audioContext.createAnalyser();\n   this.masterBus.connect(this.analyser); // Connect the master bus to the analyser\n   this.analyser.connect(this.audioContext.destination); // Connect the analyser to the destination\n   this.analyser.fftSize = 2048; // Example FFT size\n   this.analyser.smoothingTimeConstant = 0.8; // Example smoothing time constant\n   */\n\n\n    this.setRenderer('default', defaultRender);\n\n    return this;\n\n  }\n\n  async unload() {\n\n    console.log('Unloading track:', this);\n\n    this.metadata = {};\n\n    // remove t.element from the DOM\n    if (this.waveform) {\n      this.waveform.destroy();\n    }\n\n    if (!this.isLoaded) return;\n    // Cleanup audio nodes\n    this.audioNodes.clear();\n    if (this.source) {\n      this.source.disconnect();\n    }\n\n    if (this.audioElement) {\n      this.audioElement.pause();\n      this.audioElement.src = '';\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n    }\n\n    // clean-up audioContext and audioBuffer\n    this.audioContext = null;\n    this.audioBuffer = null;\n\n    this.isLoaded = false;\n\n\n    console.log('track should be fully unloaded now going to rebind with empty data', this);\n    this.databind();\n  }\n\n  async remove() {\n    await this.unload();\n    await this.unrender();\n  }\n\n  // Rendering methods\n  setRenderer(name, renderFunction) {\n    // this.renderer = renderFunction; // set as active renderer, maybe can remove this\n    this.renderers.set(name, renderFunction);\n    this.currentRenderer = name;\n  }\n\n  databind() {\n    const renderer = this.renderers.get(this.currentRenderer);\n    if (!renderer) {\n      throw new Error(`No renderer found for name: ${this.currentRenderer}`);\n    }\n    const databind = renderer.databind;\n    if (!databind) {\n      throw new Error(`No databind function found for renderer: ${this.currentRenderer}`);\n    }\n    return databind(this);\n  }\n\n  render() {\n    if (this.isRendered) {\n      return this.element;\n    }\n\n    const renderer = this.renderers.get(this.currentRenderer);\n    const render = renderer.render;\n    const databind = renderer.databind;\n    console.log(\"using renderer:\", this.currentRenderer, renderer);\n    if (!renderer) {\n      throw new Error(`No renderer found for name: ${this.currentRenderer}`);\n    }\n\n    this.element = render(this);\n    this.isRendered = true;\n    return this.element;\n  }\n\n  unrender() {\n    if (!this.isRendered || !this.element) return;\n\n    this.element.remove();\n    this.element = null;\n    this.isRendered = false;\n  }\n\n  // UI Data methods\n  setData(data) {\n    this.metadata = { ...this.metadata, ...data };\n\n    if (this.isRendered) {\n      this._updateRenderedData(data);\n    }\n  }\n\n  switchLayout(rendererName) {\n    if (!this.renderers.has(rendererName)) {\n      throw new Error(`No renderer found for name: ${rendererName}`);\n    }\n\n    this.unrender();\n    this.currentRenderer = rendererName;\n    return this.render();\n  }\n\n  // Audio graph methods\n  addNode(name, node) {\n    console.log(\"Adding node:\", name, node, this);\n    if (!this.isLoaded || !this.source) {\n      throw new Error('Cannot add node: track not loaded');\n    }\n\n    // If this node already exists, remove it first\n    if (this.audioNodes.has(name)) {\n      this.removeNode(name);\n    }\n\n    // Store the node\n    this.audioNodes.set(name, node);\n\n    // Reconnect the audio graph\n    this._reconnectAudioGraph();\n  }\n\n  removeNode(name) {\n    if (!this.audioNodes.has(name)) return;\n\n    const node = this.audioNodes.get(name);\n    node.disconnect();\n    this.audioNodes.delete(name);\n\n    // Reconnect the remaining nodes\n    this._reconnectAudioGraph();\n  }\n\n  addAnalyzer(name, analyzer) {\n    if (this.analyzers.has(name)) {\n      this.removeAnalyzer(name); // Remove existing analyzer if it's already there\n    }\n    this.analyzers.set(name, analyzer);\n    this.distributionNode.connect(analyzer); // Connect new analyzer\n  }\n\n  removeAnalyzer(name) {\n    if (this.analyzers.has(name)) {\n      this.distributionNode.disconnect(this.analyzers.get(name)); // Disconnect analyzer\n      this.analyzers.delete(name);\n    }\n  }\n\n  // Private methods\n  async _initializeAudio() {\n    // Implementation for initializing audio context and source\n  }\n\n  async _loadAudioFile(url) {\n    // Implementation for loading audio file\n  }\n\n  _reconnectAudioGraph() {\n    let lastNode = this.masterBus;\n    this.audioNodes.forEach(node => {\n      lastNode.disconnect(); // Disconnect from previous node\n      lastNode.connect(node); // Connect current node\n      lastNode = node; // Update lastNode\n    });\n    lastNode.disconnect(); // Ensure no double connections\n    lastNode.connect(this.distributionNode); // Connect the final processing node to the analyser\n    this.distributionNode.connect(this.audioContext.destination); // Connect the analyser to the destination\n  }\n\n\n  _updateRenderedData(data) {\n    console.log(\"Updating rendered data:\", data);\n    // Implementation for updating DOM elements with new data\n  }\n\n  pause() {\n    // check to make sure is not already playing\n    if (!this.audioElement.paused) {\n      this.audioElement.pause();\n    }\n\n  }\n\n  play() {\n\n    // check to make sure is not already playing\n    if (this.audioElement.paused) {\n      console.log(\"Playing audio track\");\n      this.audioElement.play();\n    }\n  }\n\n  playPause() {\n    if (this.audioElement.paused) {\n      this.play();\n    } else {\n      this.pause();\n    }\n  }\n\n  setTime(time) {\n    this.audioElement.currentTime = time;\n  }\n\n  cueTo(cueNumber) {\n\n    const cue = this.metadata.cuePoints[cueNumber - 1] ?? 0;\n    let cueTime = cue.time;\n    //cueTime -= 4;\n    console.log(\"CUE TO TIME\", cueTime);\n\n    // Set the time first, then we can determine if phase lock of sync needs to be performed\n    // a phase lock true will mean that we don't start / play / cue the track until time is ready ( forward delay )\n    // This is like reverse direction of the current phaseLockPlayback which is a backward delay\n    // for cueing with a forward motion, we need to delay the play / cue until the time is ready\n\n    // will this \"click?\"? do we need to toggle volume or order?\n    this.setTime(cueTime); // Snap precisely to cueTime\n\n\n  }\n\n  setCuePoint(cueNumber, time) {\n    let cue = {\n      time: time,\n      name: `Cue ${cueNumber}`,\n      type: 'cue'\n    };\n    this.metadata.cuePoints[cueNumber - 1] = cue;\n\n    // update the cue point in the UI ??\n    //transport.renderCuePoint(cueNumber - 1, t.detailedWaveform, t, cue)\n    //transport.renderCuePoint(cueNumber - 1, t.overviewWaveform, t, cue)\n\n    // optionally save the track with new metadata\n    // library.updateTrackData(t);\n\n  }\n\n  isPlaying() {\n    return !this.audioElement.paused;\n  }\n\n  emit(event, data) {\n    // console.log(\"AudioTrack Emitting event:\", event, data);\n    if (this.eventListeners[event]) {\n      this.eventListeners[event].forEach(callback => callback(data));\n    }\n  }\n\n  on(event, callback) {\n    if (!this.eventListeners[event]) {\n      this.eventListeners[event] = [];\n    }\n    this.eventListeners[event].push(callback);\n  }\n\n  toggleMute() {\n    this.audioElement.muted = !this.audioElement.muted;\n  }\n\n  toggleKeyLock() {\n    this.audioElement.preservesPitch = !this.audioElement.preservesPitch;\n  }\n\n  mute() {\n    this.audioElement.muted = true;\n    // set the style on the volumeSliderIcon if exists\n    if (this.transport.volumeSliderIcon) {\n      this.transport.volumeSliderIcon.classList.remove('headphones-active');\n      this.transport.volumeSliderIcon.classList.add('headphones-inactive');\n    }\n  }\n\n  unmute() {\n    this.audioElement.muted = false;\n    // set the style on the volumeSliderIcon if exists\n    if (this.transport.volumeSliderIcon) {\n      this.transport.volumeSliderIcon.classList.remove('headphones-inactive');\n      this.transport.volumeSliderIcon.classList.add('headphones-active');\n    }\n  }\n\n  setVolume(value) {\n    this.audioElement.volume = value;\n  }\n\n  getTitle() {\n\n    let metadata = this.metadata;\n    let trackTitle = metadata.title || metadata.fileName;\n    console.log('attempting to get track title', metadata, trackTitle);\n    if (!trackTitle) {\n      return 'loading track...';\n    }\n\n    if (metadata.title) {\n      trackTitle = metadata.title;\n      if (metadata.artist) {\n        trackTitle = `${metadata.artist} - ${metadata.title}`;\n      }\n    } else if (metadata.artist) {\n      trackTitle = metadata.artist;\n    }\n    // clean up track title ( todo: rename files for real )\n    trackTitle = trackTitle.replace('_(mp3.pm)', '');\n    trackTitle = trackTitle.replace('.mp3', '');\n    // replaces all instances of _ with space\n    trackTitle = trackTitle.split('_').join(' ');\n\n    console.log(\"GOT TRACK TITLE\", trackTitle);\n    return trackTitle;\n\n\n  }\n\n}\n\nTrack.prototype.getAudioBuffer = async function () {\n  this.audioBuffer = await this.audioContext.decodeAudioData(audioData);\n}\n\nTrack.prototype.setBPM = setBPM;\n\n\n\n/*\nclass Track2 {\n  constructor(options = {}) {\n    this.id = options.id || `track-${Math.random().toString(36).substr(2, 9)}`;\n    this.metadata = options.metadata || {};\n\n    // Audio properties\n    this.source = null;\n    this.audioNodes = new Map();\n\n    // UI properties\n    this.element = null;\n    this.renderers = new Map();\n    this.currentRenderer = 'default';\n\n    // State\n    this.isLoaded = false;\n    this.isRendered = false;\n\n    // Playback state\n    this.isPlaying = false;\n    this.currentTime = 0;\n    this.volume = 1.0;\n    this.speed = 1.0;\n\n    // Beat-matching properties\n    this.beatGridOffset = 0;  // milliseconds offset for beat grid alignment\n    this.syncEnabled = false;\n    this.quantizeEnabled = false;\n\n    // Loop and cue points\n    this.loops = new Map();   // stored as {startTime, endTime, enabled}\n    this.cuePoints = new Map(); // stored as {time, color, name}\n\n    // Effects state\n    this.effectsChain = [];   // order of effects in the chain\n    this.effectsEnabled = new Map();  // which effects are active\n\n    // Analysis results\n    this.waveformData = null;\n    this.beatData = null;\n    this.phraseData = null;\n  }\n\n  // Existing methods...\n\n  // New Playback Methods\n  play(time = this.currentTime) {\n    this.currentTime = time;\n    this.isPlaying = true;\n    // Implementation\n  }\n\n  pause() {\n    this.isPlaying = false;\n    // Implementation\n  }\n\n  seek(time) {\n    this.currentTime = time;\n    // Implementation\n  }\n\n  setVolume(value) {\n    this.volume = Math.max(0, Math.min(1, value));\n    // Implementation\n  }\n\n  setSpeed(value) {\n    this.speed = value;\n    // Implementation\n  }\n\n  // Beat-matching Methods\n  setBeatGridOffset(offset) {\n    this.beatGridOffset = offset;\n    // Update beat grid visualization\n  }\n\n  toggleSync() {\n    this.syncEnabled = !this.syncEnabled;\n    // Implementation\n  }\n\n  toggleQuantize() {\n    this.quantizeEnabled = !this.quantizeEnabled;\n    // Implementation\n  }\n\n  // Loop Methods\n  addLoop(id, startTime, endTime) {\n    this.loops.set(id, {\n      startTime,\n      endTime,\n      enabled: false\n    });\n  }\n\n  toggleLoop(id) {\n    const loop = this.loops.get(id);\n    if (loop) {\n      loop.enabled = !loop.enabled;\n      // Implementation\n    }\n  }\n\n  // Cue Point Methods\n  setCuePoint(id, options = {}) {\n    this.cuePoints.set(id, {\n      time: options.time || this.currentTime,\n      color: options.color || '#ffffff',\n      name: options.name || `Cue ${this.cuePoints.size + 1}`\n    });\n  }\n\n  jumpToCue(id) {\n    const cue = this.cuePoints.get(id);\n    if (cue) {\n      this.seek(cue.time);\n    }\n  }\n\n  // Effects Methods\n  setEffectParameter(effectId, param, value) {\n    const node = this.audioNodes.get(effectId);\n    if (node) {\n      // Implementation\n    }\n  }\n\n  reorderEffectChain(newOrder) {\n    this.effectsChain = newOrder;\n    this._reconnectAudioGraph();\n  }\n\n  // Analysis Methods\n  async analyze() {\n    await this._analyzeWaveform();\n    await this._analyzeBeatGrid();\n    await this._analyzePhrases();\n  }\n\n  // Beat Jump Methods\n  beatJump(beats) {\n    if (this.beatData) {\n      // Implementation: Jump forward/backward by number of beats\n    }\n  }\n\n  // Extended metadata methods\n  addTag(tag) {\n    if (!this.metadata.tags) {\n      this.metadata.tags = new Set();\n    }\n    this.metadata.tags.add(tag);\n  }\n\n  setRating(rating) {\n    this.metadata.rating = rating;\n    this.setData({ rating });\n  }\n\n  // History tracking\n  addToHistory(timestamp = Date.now()) {\n    if (!this.metadata.playHistory) {\n      this.metadata.playHistory = [];\n    }\n    this.metadata.playHistory.push(timestamp);\n  }\n\n  // Key detection and manipulation\n  detectKey() {\n    // Implementation: Analyze audio and detect musical key\n  }\n\n  setKey(key) {\n    this.metadata.detectedKey = key;\n    this.setData({ detectedKey: key });\n  }\n\n  // Extended private methods\n  async _analyzeWaveform() {\n    // Implementation: Generate waveform data\n  }\n\n  async _analyzeBeatGrid() {\n    // Implementation: Detect beats and tempo\n  }\n\n  async _analyzePhrases() {\n    // Implementation: Detect musical phrases\n  }\n\n\n}\n\n*/","\nexport default function setBPM (bpm) {\n    bpm = Number(bpm);\n    console.log('AAAA track.setBPM', this.id, bpm)\n    let waveform = this.waveform;\n\n    if (this) {\n\n        // console.log('found track bpm', this, this.bpm, bpm);\n\n        this.currentBPM = bpm;\n        const originalBPM = this.bpm || 120; // Use the current BPM or a default value\n        let playbackRate = bpm / originalBPM;\n        //track.bpm = bpm;\n        // console.log('Setting playback rate to:', playbackRate);\n        // round to nearest 2 decimals\n        playbackRate = Math.round(playbackRate * 100) / 100;\n        waveform.setPlaybackRate(playbackRate);\n\n        // track.setBPM(trackId, originalBPM);\n        this.audioElement.playbackRate = playbackRate; // Set the playback rate of the audio element\n\n        let currentBpmText = this.detailedContainer.querySelector('.current-bpm');\n        let paddedString = bpm.toFixed(2);\n        // currentBpmText.textContent = paddedString;\n\n        // in addition, we need to set the .bpm-percentage element to the percentage difference between the current BPM and the original BPM\n        // this is a simple calculation of (bpm / originalBPM) * 100\n        let bpmPercentage = (bpm / originalBPM) * 100;\n        let el = this.detailedContainer.querySelector('.bpm-percentage');\n        // round bpmPercentage to 2 decimals\n\n        // instead of percentage, value should be + or - the difference\n        // if bpmPercentage is positive, add a + sign\n        bpmPercentage = bpmPercentage - 100;\n\n        if (bpmPercentage > 0) {\n            bpmPercentage = '+' + bpmPercentage;\n        } else {\n            bpmPercentage = '' + bpmPercentage;\n        }\n        bpmPercentage = Math.round(bpmPercentage * 100) / 100;\n\n        // el.textContent = bpmPercentage + '%';\n\n\n\n\n    }\n}\n","import AudioTrackClass from './AudioTrack.js';\n\nexport default class AudioTrack {\n  constructor(bp) {\n    this.bp = bp;\n    this.AudioTrack = AudioTrackClass;\n    this.tracks = []\n  }\n\n  async init () {\n    console.log(\"AudioTrack init\");\n\n    // TODO: implement ffmpeg for decoding audio outside of main thread\n    //   await this.bp.appendScript('/v5/apps/based/audio-track/vendor/ffmpeg/ffmpeg/package/dist/umd/ffmpeg.js');\n    //   await this.bp.appendScript('/v5/apps/based/audio-track/vendor/ffmpeg/util/package/dist/umd/index.js');\n    //   await this.bp.appendScript('/v5/apps/based/audio-track/vendor/ffmpeg/util/package/dist/umd/index.js');\n\n    //<script src=\"/assets/ffmpeg/package/dist/umd/ffmpeg.js\"></script>\n    //<script src=\"/assets/util/package/dist/umd/index.js\"></script>\n\n  }\n\n  open (config) {\n    console.log(\"AudioTrack open\", config);\n  }\n\n  createAudioTrack (config) {\n    let t = new this.AudioTrack(config);\n    this.tracks.push(t);\n    return t;\n  }\n\n\n}"],"names":["defaultRender","track","container","document","createElement","className","fileName","textContent","metadata","appendChild","playPauseButton","addEventListener","console","log","isPlaying","pause","play","WebworkerFetchWithProgress","constructor","workerScript","this","worker","Worker","requests","onmessage","event","type","id","progress","data","error","request","onProgress","resolve","reject","fetch","url","options","Math","random","toString","substr","Promise","postMessage","FetchInWebWorker","bp","init","fetchWithProgress","HTTPAudioProvider","fetchInWebWorker","loadAudioData","response","arrayBuffer","arrayBufferResponse","blob","blobResponse","Track","cuePoints","provider","source","audioNodes","Map","element","renderers","currentRenderer","isLoaded","isRendered","AudioTrack","prototype","load","async","noFile","loadingProgress","_processAudioData","_setupMediaSource","isIOS","test","navigator","userAgent","window","MSStream","audioElement","src","URL","createObjectURL","duration","resolveLoad","rejectLoad","mediaSource","MediaSource","sourceBuffer","addSourceBuffer","audioBuffer","appendBuffer","err","endsWith","_initializeAudioElements","Audio","crossOrigin","preservesPitch","audioData","audioContext","decodeAudioData","fileSize","length","channelData","i","numberOfChannels","push","getChannelData","extractAudioBuffer","_decodeAudioWithFFmpeg","ffmpeg","FFmpeg","inputFileName","outputFileName","writeFile","fetchFile","exec","outputData","readFile","sampleRate","frameCount","AudioContext","createBuffer","interleaved","Float32Array","buffer","j","copyToChannel","Error","message","emit","loadingComplete","eventListeners","fx","webkitAudioContext","masterBus","createGain","distributionNode","createMediaElementSource","disconnect","connect","destination","gain","value","analyzers","setRenderer","unload","waveform","destroy","clear","close","databind","remove","unrender","name","renderFunction","set","renderer","get","render","setData","_updateRenderedData","switchLayout","rendererName","has","addNode","node","removeNode","_reconnectAudioGraph","delete","addAnalyzer","analyzer","removeAnalyzer","_initializeAudio","_loadAudioFile","lastNode","forEach","paused","playPause","setTime","time","currentTime","cueTo","cueNumber","cueTime","setCuePoint","cue","callback","on","toggleMute","muted","toggleKeyLock","mute","transport","volumeSliderIcon","classList","add","unmute","setVolume","volume","getTitle","trackTitle","title","artist","replace","split","join","getAudioBuffer","setBPM","bpm","Number","currentBPM","playbackRate","round","setPlaybackRate","detailedContainer","querySelector","toFixed","AudioTrackClass","tracks","open","config","createAudioTrack","t"],"mappings":"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"}