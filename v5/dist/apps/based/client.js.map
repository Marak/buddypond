{"version":3,"file":"client.js","sources":["../../../apps/based/client/client.js","../../../apps/based/client/lib/ws/createWebSocketClient.js"],"sourcesContent":["// Remark: We are migrating away from having client application, and instead moved each client to their own application's folder\n// This will be the client for messages, buddylist websocket is handled by apps/buddylist/lib/wsclient.js\n// TODO: Move this to /messages/client.js\nimport createWebSocketClient from './lib/ws/createWebSocketClient.js';\n\nexport default class Client {\n    constructor(bp, options = {}) {\n        this.bp = bp;\n        this.config = options.config || this.bp.config || {\n            host: \"\",\n            api: \"\",\n        };\n        \n        this.api = buddypond;\n        this.api.endpoint = `${this.config.api}/api/v6`;\n        this.queuedMessages = [];\n\n        this.messagesWsClients = new Map();\n        \n        // Track active subscriptions\n        this.subscriptions = new Map();\n\n        // Timer for keepalive\n        this.keepaliveInterval = null;\n    }\n\n    async init() {\n        let config = {\n            onmessage: (event) => this.handleWorkerMessage(event),\n            onerror: (event) => console.error(\"Worker Error:\", event),\n        };\n\n        this.worker = await this.bp.createWorker('/apps/based/client/clientWorker.js', config);\n        this.worker.onmessage = (event) => {\n            this.bp.log('Message from worker:', event.data);\n            config.onmessage(event.data);\n        };\n        \n        this.worker.onerror = (event) => {\n            console.error('Worker error:', event);\n            config.onerror(event);\n        };\n\n        return this;\n    }\n\n    startKeepaliveTimer() {\n        if (this.keepaliveInterval) return; // Prevent multiple intervals\n\n        this.keepaliveInterval = setInterval(() => {\n            //if (this.subscriptions.size > 0) {\n                buddypond.keepAlive();\n                this.bp.log('Keepalive ping sent');\n            //}\n        }, 30000); // 30 seconds interval\n    }\n\n    stopKeepaliveTimer() {\n        if (this.keepaliveInterval) {\n            clearInterval(this.keepaliveInterval);\n            this.keepaliveInterval = null;\n        }\n    }\n\n    sendWsMessage(chatId, message) {\n        let chatConnection = this.messagesWsClients.get(chatId);\n        if (!chatConnection || !chatConnection.wsClient) {\n            console.log('buddypond.messagesWs not connected, unable to send message to', chatId, message);\n            return;\n        }\n        // Send the message via ws connection\n        chatConnection.wsClient.send(JSON.stringify(message));\n    }\n\n    addSubscription(type, context) {\n        let chatId = type + '/' + context;\n      \n        if (type === 'buddy') {\n            // If the context is a buddy, create a unique chatId for the tuple\n            let buddyNames = [buddypond.me, context].sort();\n            chatId = type + '/' + buddyNames.join('/');\n        }\n        console.log(`subscribeMessages subscribing to ${chatId}`);\n\n        // Check if an entry exists in the map\n        if (!this.messagesWsClients.has(chatId)) {\n            this.createWebSocketClient(chatId);\n        }\n    }\n\n    removeSubscription(type, context) {\n        let chatId = type + '/' + context;\n      \n        if (type === 'buddy') {\n            // If the context is a buddy, create a unique chatId for the tuple\n            let buddyNames = [buddypond.me, context].sort();\n            chatId = type + '/' + buddyNames.join('/');\n        }\n      \n        console.log(`unsubscribeMessages unsubscribing from ${chatId}`);\n\n        // Check if an entry exists in the map\n        if (this.messagesWsClients.has(chatId)) {\n            console.log(`buddypond.messagesWsClients has ${chatId}, closing connection`);\n            let chatConnection = this.messagesWsClients.get(chatId);\n            console.log('closing chatConnection', chatConnection);\n      \n            console.log('Before close, readyState:', chatConnection.wsClient.readyState);\n            chatConnection.wsClient.closeConnection();\n        }\n    }\n\n    connect() {\n        // Moved to buddylist.client.connect()\n    }\n\n    sendMessage(message) {\n        this.bp.log('sendMessage', message);\n        message.me = this.api.me;\n    }\n\n    disconnect() {\n        // Iterate through all buddypond.messagesWsClients Map and closeConnection() all of them\n        this.bp.log('Disconnecting all WebSocket clients');\n        this.messagesWsClients.forEach(chatConnection => {\n            chatConnection.wsClient.closeConnection();\n        });\n    }\n\n    logout() {\n        this.disconnect();\n        this.qtokenid = null;\n        this.api.qtokenid = null;\n\n        this.api.me = 'Guest';\n        this.me = 'Guest';\n        this.bp.me = 'Guest';\n\n        localStorage.removeItem('qtokenid');\n        localStorage.removeItem('me');\n\n        // Once we have performed the logout, emit the event\n        this.bp.emit('auth::logout');\n    }\n}\n\nClient.prototype.createWebSocketClient = createWebSocketClient;","// Function to create a WebSocket client for a given chatId\n// Assume \"this\" scope is bound to the `client` object\n// Currently used for chat rooms, not buddylist\nexport default function createWebSocketClient(chatId) {\n  // Check if a chatConnection already exists for this chatId\n  let chatConnection = this.messagesWsClients.get(chatId);\n  let reconnectAttempts = 0;\n  const maxReconnectAttempts = 999999; // Set to a high number for unlimited attempts\n  const maxBackoffDelay = 10000; // 10 seconds\n\n  // If a chatConnection exists, reuse its reconnectAttempts\n  if (chatConnection) {\n    console.log(`Reusing existing chatConnection for chatId: ${chatId}, reconnectAttempts: ${chatConnection.reconnectAttempts}`);\n    reconnectAttempts = chatConnection.reconnectAttempts;\n  } else {\n    console.log(`Creating new WebSocket client for chatId: ${chatId}`);\n  }\n\n  const wsClient = new WebSocket(\n    `${buddypond.messagesWsEndpoint}?me=${buddypond.me}&qtokenid=${buddypond.qtokenid}&chatId=${chatId}`\n  );\n\n  // Create or update chatConnection object\n  chatConnection = {\n    wsClient,\n    reconnectAttempts,\n    maxReconnectAttempts,\n    maxBackoffDelay\n  };\n  this.messagesWsClients.set(chatId, chatConnection);\n\n  let isIntentionallyClosed = false; // Flag to track intentional closure\n\n  // Named function for open event\n  function handleOpen() {\n    console.log('WebSocket connection opened to', chatId);\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    chatConnection.reconnectAttempts = 0; // Sync with chatConnection\n    chatConnection.wsClient.send(\n      JSON.stringify({\n        action: 'getHistory',\n        chatId: chatId,\n        buddyname: buddypond.me,\n        qtokenid: buddypond.qtokenid,\n      })\n    );\n  }\n\n  // Named function for message event\n  async function handleMessage(event) {\n    try {\n      const parseData = JSON.parse(event.data);\n\n      switch (parseData.action) {\n        case 'message':\n          console.log('WebSocket message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n\n        case 'typing' :\n          // console.log('Typing message received:', parseData);\n          bp.emit('buddy::isTyping', parseData.message);\n          break;\n        case 'rate-limit':\n          console.log('Rate limit exceeded:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message], retryAfter: parseData.retryAfter, severity: parseData.severity } });\n          console.error(parseData.severity, parseData.message.text);\n          if (parseData.severity == 3) {\n            alert('Please chill out.');\n          }\n\n          if (parseData.severity == 4) {\n\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/forbiddenRickRoll/forbiddenRickRoll.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n\n          }\n\n\n          if (parseData.severity >= 5) {\n\n\n            /*\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/hamster-dance/hamster-dance.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n            */\n\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/vortex/vortex.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n\n\n            // logout\n            // this.bp.logout();\n          }\n          break;\n\n        case 'getHistory':\n          console.log('getHistory message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: parseData.messages } });\n          break;\n\n        case 'removeInstantMessage':\n          console.log('removeInstantMessage message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n\n        case 'editInstantMessage':\n          console.log('editInstantMessage message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n\n        default:\n          console.warn('Unknown action received:', parseData);\n          break;\n      }\n    } catch (error) {\n      console.error('Error parsing WebSocket message:', error);\n    }\n  }\n\n  // Named function for close event\n  function handleClose(event) {\n    console.log('WebSocket connection closed to', chatId, 'Code:', event.code, 'Reason:', event.reason);\n    console.log('reconnectAttempts:', chatConnection.reconnectAttempts);\n    console.log('isIntentionallyClosed:', isIntentionallyClosed);\n\n    // Only remove from Map if intentionally closed or max reconnect attempts reached\n    if (isIntentionallyClosed || chatConnection.reconnectAttempts >= chatConnection.maxReconnectAttempts) {\n      console.log(`Removing chatConnection for ${chatId} from messagesWsClients`);\n      this.messagesWsClients.delete(chatId);\n      console.log('Current WebSocket clients:', this.messagesWsClients);\n    }\n\n    // Reconnect only if the closure was not intentional and max attempts not reached\n    if (!isIntentionallyClosed && chatConnection.reconnectAttempts < chatConnection.maxReconnectAttempts) {\n      const delay = Math.min(\n        200 * Math.pow(2, chatConnection.reconnectAttempts) * (1 + 0.1 * Math.random()), // Exponential backoff with jitter\n        chatConnection.maxBackoffDelay\n      );\n      console.log(`Scheduling reconnect attempt ${chatConnection.reconnectAttempts + 1} for ${chatId} in ${delay}ms`);\n      setTimeout(() => {\n        reconnectAttempts++;\n        chatConnection.reconnectAttempts++; // Sync with chatConnection\n        createWebSocketClient.call(this, chatId); // Attempt to reconnect\n      }, delay);\n    } else if (chatConnection.reconnectAttempts >= chatConnection.maxReconnectAttempts) {\n      console.error(`Max reconnect attempts (${chatConnection.maxReconnectAttempts}) reached for ${chatId}. Giving up.`);\n    }\n  }\n\n  // Named function for error event\n  function handleError(event) {\n    console.error('WebSocket error for', chatId, event);\n    // Close the WebSocket to trigger the close handler\n    chatConnection.wsClient.close(1000, 'Error occurred');\n  }\n\n  // Add event listeners with named functions\n  wsClient.addEventListener('open', handleOpen.bind(this));\n  wsClient.addEventListener('message', handleMessage.bind(this));\n  wsClient.addEventListener('close', handleClose.bind(this));\n  wsClient.addEventListener('error', handleError.bind(this));\n\n  // Method to intentionally close the WebSocket\n  wsClient.closeConnection = function () {\n    isIntentionallyClosed = true;\n    console.log(`Intentionally closing WebSocket for ${chatId}`);\n    chatConnection.wsClient.close(1000, 'Normal closure');\n    // Remove event listeners to prevent memory leaks\n    chatConnection.wsClient.removeEventListener('open', handleOpen);\n    chatConnection.wsClient.removeEventListener('message', handleMessage);\n    chatConnection.wsClient.removeEventListener('close', handleClose);\n    chatConnection.wsClient.removeEventListener('error', handleError);\n  };\n\n  return wsClient;\n}"],"names":["Client","constructor","bp","options","this","config","host","api","buddypond","endpoint","queuedMessages","messagesWsClients","Map","subscriptions","keepaliveInterval","init","onmessage","event","handleWorkerMessage","onerror","console","error","worker","createWorker","log","data","startKeepaliveTimer","setInterval","keepAlive","stopKeepaliveTimer","clearInterval","sendWsMessage","chatId","message","chatConnection","get","wsClient","send","JSON","stringify","addSubscription","type","context","me","sort","join","has","createWebSocketClient","removeSubscription","readyState","closeConnection","connect","sendMessage","disconnect","forEach","logout","qtokenid","localStorage","removeItem","emit","prototype","reconnectAttempts","WebSocket","messagesWsEndpoint","maxReconnectAttempts","maxBackoffDelay","set","isIntentionallyClosed","handleOpen","action","buddyname","async","handleMessage","parseData","parse","result","messages","retryAfter","severity","text","alert","importModule","default","call","warn","handleClose","code","reason","delete","delay","Math","min","pow","random","setTimeout","handleError","close","addEventListener","bind","removeEventListener"],"mappings":"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"}