{"version":3,"file":"client.js","sources":["../../../apps/based/client/client.js","../../../apps/based/client/lib/ws/createWebSocketClient.js"],"sourcesContent":["// Remark: We are migrating away from having client application, and instead moved each client to their own application's folder\n// This will be the client for messages, buddylist websocket is handled by apps/buddylist/lib/wsclient.js\n// TODO: Move this to /messages/client.js\nimport createWebSocketClient from './lib/ws/createWebSocketClient.js';\n\nexport default class Client {\n    constructor(bp, options = {}) {\n        this.bp = bp;\n        this.config = options.config || this.bp.config || {\n            host: \"\",\n            api: \"\",\n        };\n        \n        this.api = buddypond;\n        this.api.endpoint = `${this.config.api}/api/v6`;\n        this.queuedMessages = [];\n\n        this.messagesWsClients = new Map();\n        \n        // Track active subscriptions\n        this.subscriptions = new Map();\n\n        // Timer for keepalive\n        this.keepaliveInterval = null;\n    }\n\n    async init() {\n        let config = {\n            onmessage: (event) => this.handleWorkerMessage(event),\n            onerror: (event) => console.error(\"Worker Error:\", event),\n        };\n\n        this.worker = await this.bp.createWorker('/apps/based/client/clientWorker.js', config);\n        this.worker.onmessage = (event) => {\n            this.bp.log('Message from worker:', event.data);\n            config.onmessage(event.data);\n        };\n        \n        this.worker.onerror = (event) => {\n            console.error('Worker error:', event);\n            config.onerror(event);\n        };\n\n        return this;\n    }\n\n    startKeepaliveTimer() {\n        if (this.keepaliveInterval) return; // Prevent multiple intervals\n\n        this.keepaliveInterval = setInterval(() => {\n            //if (this.subscriptions.size > 0) {\n                buddypond.keepAlive();\n                this.bp.log('Keepalive ping sent');\n            //}\n        }, 30000); // 30 seconds interval\n    }\n\n    stopKeepaliveTimer() {\n        if (this.keepaliveInterval) {\n            clearInterval(this.keepaliveInterval);\n            this.keepaliveInterval = null;\n        }\n    }\n\n    sendWsMessage(chatId, message) {\n        let chatConnection = this.messagesWsClients.get(chatId);\n        if (!chatConnection || !chatConnection.wsClient) {\n            console.log('buddypond.messagesWs not connected, unable to send message to', chatId, message);\n            return;\n        }\n        // Send the message via ws connection\n        chatConnection.wsClient.send(JSON.stringify(message));\n    }\n    \n    getConnectedUsers(chatId) {\n        alert('getConnectedUsers called for ' + chatId);\n        // sends a getConnectedUsers webscket message to the server\n        this.bp.log('getConnectedUsers called');\n        if (this.messagesWsClients.has(chatId)) {\n            let chatConnection = this.messagesWsClients.get(chatId);\n            if (chatConnection && chatConnection.wsClient) {\n                this.bp.log('buddypond.messagesWsClients has', chatId, 'sending getConnectedUsers message');\n                chatConnection.wsClient.send(JSON.stringify({ action: 'getConnectedUsers' }));\n            } else {\n                this.bp.log('No WebSocket client found for', chatId);\n            }\n        }\n        else {\n            this.bp.log('No WebSocket client found for', chatId, 'unable to send getConnectedUsers message');\n        }\n\n    }\n\n    addSubscription(type, context) {\n        let chatId = type + '/' + context;\n      \n        if (type === 'buddy') {\n            // If the context is a buddy, create a unique chatId for the tuple\n            let buddyNames = [buddypond.me, context].sort();\n            chatId = type + '/' + buddyNames.join('/');\n        }\n        console.log(`subscribeMessages subscribing to ${chatId}`);\n\n        // Check if an entry exists in the map\n        if (!this.messagesWsClients.has(chatId)) {\n            this.createWebSocketClient(chatId);\n        }\n    }\n\n    removeSubscription(type, context) {\n        let chatId = type + '/' + context;\n      \n        if (type === 'buddy') {\n            // If the context is a buddy, create a unique chatId for the tuple\n            let buddyNames = [buddypond.me, context].sort();\n            chatId = type + '/' + buddyNames.join('/');\n        }\n      \n        console.log(`unsubscribeMessages unsubscribing from ${chatId}`);\n\n        // Check if an entry exists in the map\n        if (this.messagesWsClients.has(chatId)) {\n            console.log(`buddypond.messagesWsClients has ${chatId}, closing connection`);\n            let chatConnection = this.messagesWsClients.get(chatId);\n            console.log('closing chatConnection', chatConnection);\n      \n            console.log('Before close, readyState:', chatConnection.wsClient.readyState);\n            chatConnection.wsClient.closeConnection();\n        }\n    }\n\n    connect() {\n        // Moved to buddylist.client.connect()\n    }\n\n    sendMessage(message) {\n        this.bp.log('sendMessage', message);\n        message.me = this.api.me;\n    }\n\n    disconnect() {\n        // Iterate through all buddypond.messagesWsClients Map and closeConnection() all of them\n        this.bp.log('Disconnecting all WebSocket clients');\n        this.messagesWsClients.forEach(chatConnection => {\n            chatConnection.wsClient.closeConnection();\n        });\n    }\n\n    logout() {\n        this.disconnect();\n        this.qtokenid = null;\n        this.api.qtokenid = null;\n\n        this.api.me = 'Guest';\n        this.me = 'Guest';\n        this.bp.me = 'Guest';\n        this.bp.qtokenid = null;\n\n        localStorage.removeItem('qtokenid');\n        localStorage.removeItem('me');\n\n        // Once we have performed the logout, emit the event\n        this.bp.emit('auth::logout');\n    }\n}\n\nClient.prototype.createWebSocketClient = createWebSocketClient;","// Function to create a WebSocket client for a given chatId\n// Assume \"this\" scope is bound to the `client` object\n// Currently used for chat rooms, not buddylist\nexport default function createWebSocketClient(chatId) {\n  // Check if a chatConnection already exists for this chatId\n  let chatConnection = this.messagesWsClients.get(chatId);\n  let reconnectAttempts = 0;\n  const maxReconnectAttempts = 999999; // Set to a high number for unlimited attempts\n  const maxBackoffDelay = 10000; // 10 seconds\n\n  // If a chatConnection exists, reuse its reconnectAttempts\n  if (chatConnection) {\n    console.log(`Reusing existing chatConnection for chatId: ${chatId}, reconnectAttempts: ${chatConnection.reconnectAttempts}`);\n    reconnectAttempts = chatConnection.reconnectAttempts;\n  } else {\n    console.log(`Creating new WebSocket client for chatId: ${chatId}`);\n  }\n\n  const wsClient = new WebSocket(\n    `${buddypond.messagesWsEndpoint}?me=${buddypond.me}&qtokenid=${buddypond.qtokenid}&chatId=${chatId}`\n  );\n\n  // Create or update chatConnection object\n  chatConnection = {\n    wsClient,\n    reconnectAttempts,\n    maxReconnectAttempts,\n    maxBackoffDelay\n  };\n  this.messagesWsClients.set(chatId, chatConnection);\n\n  let isIntentionallyClosed = false; // Flag to track intentional closure\n\n  // Named function for open event\n  function handleOpen() {\n    console.log('WebSocket connection opened to', chatId);\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    chatConnection.reconnectAttempts = 0; // Sync with chatConnection\n    chatConnection.wsClient.send(\n      JSON.stringify({\n        action: 'getHistory',\n        chatId: chatId,\n        profilePicture: this.bp.apps.buddylist.data.profileState.profilePicture,\n        buddyname: buddypond.me,\n        qtokenid: buddypond.qtokenid,\n      })\n    );\n\n    chatConnection.wsClient.send(\n      JSON.stringify({\n        action: 'getConnectedUsers',\n        chatId: chatId,\n        buddyname: buddypond.me,\n        qtokenid: buddypond.qtokenid,\n      })\n    );\n\n    // Remark: attempt to set .aim-room-active class on the .aim-room-list-item-name, which is a child\n    // of the .aim-room-list-item with data-pond of chatId\n    // TODO: Move this code elsewhere, not in the client\n    // we may want to bp.emit('pond::connected') event instead\n    const chatWindow = this.bp.apps.ui.windowManager.getWindow('pond_message_main');\n    if (chatWindow) {\n      const roomListItem = chatWindow.content.querySelector(`.aim-room-item[data-pond=\"${chatId}\"]`);\n      if (roomListItem) {\n        const roomNameElement = roomListItem.querySelector('.aim-room-list-item-name');\n        if (roomNameElement) {\n          roomNameElement.classList.add('aim-room-active');\n        }\n      }\n    }\n\n\n  }\n\n  // Named function for message event\n  async function handleMessage(event) {\n    try {\n      const parseData = JSON.parse(event.data);\n\n      switch (parseData.action) {\n        case 'message':\n          // console.log('WebSocket message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n        case 'connectedUsers':\n          // console.log('Connected users message received:', parseData);\n          bp.emit('pond::connectedUsers', parseData);\n          break;\n        case 'typing' :\n          // console.log('Typing message received:', parseData);\n          bp.emit('buddy::isTyping', parseData.message);\n          break;\n        case 'rate-limit':\n          console.log('Rate limit exceeded:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message], retryAfter: parseData.retryAfter, severity: parseData.severity } });\n          console.error(parseData.severity, parseData.message.text);\n          if (parseData.severity == 3) {\n            alert('Please chill out.');\n          }\n\n          if (parseData.severity == 4) {\n\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/forbiddenRickRoll/forbiddenRickRoll.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n\n          }\n\n\n          if (parseData.severity >= 5) {\n\n\n            /*\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/hamster-dance/hamster-dance.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n            */\n\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/vortex/vortex.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n\n\n            // logout\n            // this.bp.logout();\n          }\n          break;\n\n        case 'getHistory':\n          // console.log('getHistory message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: parseData.messages } });\n          break;\n\n        case 'removeInstantMessage':\n          console.log('removeInstantMessage message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n\n        case 'editInstantMessage':\n          console.log('editInstantMessage message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n\n        default:\n          console.warn('Unknown action received:', parseData);\n          break;\n      }\n    } catch (error) {\n      console.error('Error parsing WebSocket message:', error);\n    }\n  }\n\n  // Named function for close event\n  function handleClose(event) {\n    console.log('WebSocket connection closed to', chatId, 'Code:', event.code, 'Reason:', event.reason);\n    console.log('reconnectAttempts:', chatConnection.reconnectAttempts);\n    console.log('isIntentionallyClosed:', isIntentionallyClosed);\n\n    // Only remove from Map if intentionally closed or max reconnect attempts reached\n    if (isIntentionallyClosed || chatConnection.reconnectAttempts >= chatConnection.maxReconnectAttempts) {\n      console.log(`Removing chatConnection for ${chatId} from messagesWsClients`);\n      this.messagesWsClients.delete(chatId);\n      console.log('Current WebSocket clients:', this.messagesWsClients);\n    }\n\n    // Reconnect only if the closure was not intentional and max attempts not reached\n    if (!isIntentionallyClosed && chatConnection.reconnectAttempts < chatConnection.maxReconnectAttempts) {\n      const delay = Math.min(\n        200 * Math.pow(2, chatConnection.reconnectAttempts) * (1 + 0.1 * Math.random()), // Exponential backoff with jitter\n        chatConnection.maxBackoffDelay\n      );\n      console.log(`Scheduling reconnect attempt ${chatConnection.reconnectAttempts + 1} for ${chatId} in ${delay}ms`);\n      setTimeout(() => {\n        reconnectAttempts++;\n        chatConnection.reconnectAttempts++; // Sync with chatConnection\n        createWebSocketClient.call(this, chatId); // Attempt to reconnect\n      }, delay);\n    } else if (chatConnection.reconnectAttempts >= chatConnection.maxReconnectAttempts) {\n      console.error(`Max reconnect attempts (${chatConnection.maxReconnectAttempts}) reached for ${chatId}. Giving up.`);\n    }\n  }\n\n  // Named function for error event\n  function handleError(event) {\n    console.error('WebSocket error for', chatId, event);\n    // Close the WebSocket to trigger the close handler\n    chatConnection.wsClient.close(1000, 'Error occurred');\n  }\n\n  // Add event listeners with named functions\n  wsClient.addEventListener('open', handleOpen.bind(this));\n  wsClient.addEventListener('message', handleMessage.bind(this));\n  wsClient.addEventListener('close', handleClose.bind(this));\n  wsClient.addEventListener('error', handleError.bind(this));\n\n  // Method to intentionally close the WebSocket\n  wsClient.closeConnection = function () {\n    isIntentionallyClosed = true;\n    console.log(`Intentionally closing WebSocket for ${chatId}`);\n    chatConnection.wsClient.close(1000, 'Normal closure');\n    // Remove event listeners to prevent memory leaks\n    chatConnection.wsClient.removeEventListener('open', handleOpen);\n    chatConnection.wsClient.removeEventListener('message', handleMessage);\n    chatConnection.wsClient.removeEventListener('close', handleClose);\n    chatConnection.wsClient.removeEventListener('error', handleError);\n  };\n\n  return wsClient;\n}"],"names":["Client","constructor","bp","options","this","config","host","api","buddypond","endpoint","queuedMessages","messagesWsClients","Map","subscriptions","keepaliveInterval","init","onmessage","event","handleWorkerMessage","onerror","console","error","worker","createWorker","log","data","startKeepaliveTimer","setInterval","keepAlive","stopKeepaliveTimer","clearInterval","sendWsMessage","chatId","message","chatConnection","get","wsClient","send","JSON","stringify","getConnectedUsers","alert","has","action","addSubscription","type","context","me","sort","join","createWebSocketClient","removeSubscription","readyState","closeConnection","connect","sendMessage","disconnect","forEach","logout","qtokenid","localStorage","removeItem","emit","prototype","reconnectAttempts","WebSocket","messagesWsEndpoint","maxReconnectAttempts","maxBackoffDelay","set","isIntentionallyClosed","handleOpen","profilePicture","apps","buddylist","profileState","buddyname","chatWindow","ui","windowManager","getWindow","roomListItem","content","querySelector","roomNameElement","classList","add","async","handleMessage","parseData","parse","result","messages","retryAfter","severity","text","importModule","default","call","warn","handleClose","code","reason","delete","delay","Math","min","pow","random","setTimeout","handleError","close","addEventListener","bind","removeEventListener"],"mappings":"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"}